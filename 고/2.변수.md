# 변수



## Go의 변수

### Go는 정적 언어이기 때문에 변수에 크기를 할당해 주어야 합니다.

```go
var number int = 100
```

크기의 종류는 다음과 같습니다.

| 자료형     | 저장범위                                               | 설명                                                   |
| ---------- | ------------------------------------------------------ | ------------------------------------------------------ |
| uint8      | 0 ~ 255                                                | 부호 없는 8비트 정수형                                 |
| uint16     | 0 ~ 65,535                                             | 부호 없는 16비트 정수형                                |
| unit32     | 0 ~ 4,294,967,295                                      | 부호 없는 32비트 정수형                                |
| uint64     | 0 ~ 18,446,744,073,709,551,615                         | 부호 없는 64비트 정수형                                |
| uint       |                                                        | 32비트 시스템에서는 uint32, 64비트 시스템에서는 uint64 |
| int8       | -128 ~ 127                                             | 부호 있는 8비트 정수형                                 |
| int16      | -32,768 ~ 32,767                                       | 부호 있는 16비트 정수형                                |
| int32      | -2,147,483,648 ~ 2,147,483,647                         | 부호 있는 32비트 정수형                                |
| int64      | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 부호 있는 64비트 정수형                                |
| int        |                                                        | 32비트 시스템에서는 int32, 64비트 시스템에서는 int64   |
| float32    |                                                        | IEEE-754 32비트 부동소수점, 7자리 정밀도               |
| float64    |                                                        | IEEE-754 64비트 부동소수점, 12자리 정밀도              |
| complex64  |                                                        | float32 크기의 실수부와 허수부로 구성된 복소수         |
| complex128 |                                                        | float64 크기의 실수부와 허수부로 구성된 복소수         |
| uintptr    |                                                        | uint와 같은 크기를 갖는 포인터형                       |
| bool       |                                                        | 참, 거짓을 표현하기 위한 8비트 자료형                  |
| byte       |                                                        | 8비트 자료형                                           |
| rune       |                                                        | 유니코드 저장을 위한 자료형, 크기는 int32와 동일       |
| string     |                                                        | 문자열을 저장하기 위한 자료형                          |



### 변수 선언은 일반적으로 `var` 를 사용하지만 다음과 같이 사용할수 있습니다.

```go
package main

import "fmt"

func main() {
	var a int = 1
	var b int   // 변수를 초기화 해주지 않으면 기본으로 0으로 설정됩니다.
	var c = 3
	d := 4

	fmt.Println(a, b, c, d)
}

// 결과 
// 1 0 3 4
 
```



### 다음은 모든 변수의 초기값 입니다.

| 타입                                    | 기본값                                               |
| --------------------------------------- | ---------------------------------------------------- |
| 모든 정수 타입 (int, byte ...)          | 0                                                    |
| 모든 실수 타입 (float32, complex64 ...) | 0.0                                                  |
| 불리언 타입(bool)                       | false                                                |
| 문자열 타입(string)                     | ""                                                   |
| 그외 타입                               | nil (정의되지 않은 메모리 주소를 나타내는 Go 키워드) |



### 숫자의 기본 타입

타입을 생략하면 우변의 타입으로 좌변의 타입이 지정됩니다. 만약 우변이 숫자이면 기본타입으로 결정 됩니다.

정수는 int, 실수는 float64가 기본 타입입니다.



### 선언 대입문 :=

말 그대로 선언과 대입을 한번에 하는 구문입니다. 선언 대입문을 사용하면 var 키워드 타입을 생략할 수 있습니다.

```go
var b = 3.141519      // float64 자동 지정
c := 365 							// int 자동 지정
s := "Jerry And Tom"  // string 자동 지정
```







## 타입 변환

프로그래밍을 구분할때 타입 검사를 하는가 안 하는가에 따라 강타입 언어와 약타입 언어로 구분됩니다.

Go는 그 중 가장 강하게 타입 검사를 하는 최강 타입 언어입니다.

```go
	a := 3
	b := 3.3
	
	// 잘못된 연산: a * b (일치하지 않는 타입 int와(과) float64)
	fmt.Println(a * b)
	
	var c int64 = 9999
	var d int = 8888
	
	// 잘못된 연산: c * d (일치하지 않는 타입 int64와(과) int)
	fmt.Println(c * d)
	
	var e string = "365"
	var f int = 32

	// 잘못된 연산: e * f (일치하지 않는 타입 string와(과) int)
	fmt.Println(e + f)
```



 그래서 변환을 해주는 작업이 필요합니다.

그리고 변환시 주의 해야 할점을 항상 염두해야 합니다.

```go
	a := 3
	b := 3.3

	fmt.Println(float64(a) * b)

	var c int64 = 9999
	var d int = 8888

	fmt.Println(int(c) * d)

	var e string = "365"
	var f int = 32

	fmt.Println(e + string(f))

	var g = 5.9332

	// 주의!! float 타입을 정수형으로 변환시 소수점 이하가 없어(반올림 x 버림 o)집니다.
	fmt.Println(int(g))

	var h int16 = 3456

	// 주의!! 큰 타입에서 작은 타입으로 변환시 상위 1byte가 없어졌기 때문에 - 처리됩니다.
	fmt.Println(int8(h))

	// 결과
 	// 9.899999999999999
	// 88871112
	// 365 
	// 5
	// -128
```



>### Go에서 음수 표현
>
>숫자 `15`를 1byte 2진수로 표현하면 다음과 같습니다.
>
>```bash
>0   0 0 0 1 1 1 1
>```
>
>그럼 음수 `-15`를 표현하는 방법은 다음과 같을 까요?
>
>```bash
>1   0 0 0 1 1 1 1
>```
>
>정답은 그렇지 않습니다.
>
>왜냐하면 단순히 최상위 비트가 1 이냐 0 이냐에 따라서 판단을 하게 되면 +0 과 -0 이라는 이상한 개념이 생기기 때문입니다.
>
>게다가 표현을 할 수 있는 숫자가 하나 줄어들어 낭비가 발생하기 때문에 컴퓨터에서는 절댓값의 2의 보수로 표현합니다.
>
>**2의 보수**를 만드는 방법은 **모든 비트의 0을 1로, 1을 0으로 만든뒤 1을 더하면** 됩니다.
>
>```bash
>0   0 0 0 1 1 1 1
>
># 비트 반전
>1   1 1 1 0 0 0 0
>
># 1 더하기 (-15 가 표현되었습니다.)
>1   1 1 1 0 0 0 1
>```

>### Go에서 실수 표현
>
>Go에서는 실수 표현을 IEEE-754 표준을 따라 실수를 표현합니다.
>
>예를들어 1024.234 는 0.1024234 * 10^4 로 나타낼 수도 있고, 0.1024234e+e4라고 쓰기도 합니다.
>
>이런 원칙에 따라 어느정도 표현의 한계가 있는데요
>
>| 타입    | 최솟값                  | 최댓값                 | 소수부 |
>| ------- | ----------------------- | ---------------------- | ------ |
>| float32 | 1.175494351e-38         | 3.402823466e38         | 7자리  |
>| float62 | 2.2250738585072014e-308 | 1.7976931348623158e308 | 15자리 |
>
>이런 방식으로 Go는 실수값을 표현할때 정확한 값이 아닌 타입이 허용하는 범위에서 가장 가까운 근삿값으로 표현하게 됩니다.
>
>그래서 가끔 계산에 오류가 생길수 있습니다.
>
>```go
>package main
>
>import "fmt"
>
>func main() {
>	var a float32 = 1234.523
>	var b float32 = 3456.123
>	var result float32
>	for i := 0; i < 100; i++ {
>		result = a * b
>
>	}
>	fmt.Println(result)
>}
>
>// 결과값
>// 4.266663e+06
>```
>
>정확한 결과는 4266663.334329 이지만 float32의 7자리 제한에 걸려 4266663이 됩니다.
>
>이는 **계산이 거듭될수록 큰 차이를 야기하며** 금융이나 회계등 정확한 숫자 값을 요구하는 프로젝트에서는
>
>**반드시 숫자타입의 사용에 충분한 고려와 주의**가 필요합니다.
