# 상수



## 상수 선언

상수란 절대 변하지 않는 값을 말합니다.

한번 선언(초기화) 시킨 함수는 그 값을 유지하고 변하지 않습니다.

Go에서 상수로 선언할수 있는 변수의 타입은 다음과 같습니다.

- 불리언
- 룬(rune)
- 정수
- 문자열
- 복소수

상수 선언 방식은 변수와 비슷합니다.

변수를 뜻하는 `var` (variable) 대신 `const` (constant) 키워드를 사용한다는 점이 다릅니다.

```go
const ConstVal int = 10
```



다만 상수에서 **함수 외부에서 선언되어있고 첫 글자가 대문자인 상수**는 패키지 외부로 공개되는 상수입니다.

상수는 오직 값으로만 동작합니다.

그래서 변수가 값, 이름, 타입, 메모리 주소 4가지 속성을 가지는 반면 상수는 값, 이름, 타입 3가지 속성만 가집니다.

```go
package main

import "fmt"

const GlobalC int = 100 

func main() {
	const C = 0
	b := C * 20
  C = 10 // error : C에 대입 할수 없습니다.
	
  // &를 변수 앞에 사용하면 그 변수의 메모리 주솟값을 반환한다.
  // 하지만 상수 앞에 사용하면 상수의 메모리 주솟값을 접근할 수 없기 때문에 에러가 발생한다.
  
  fmt.Println(&C) // error : 'C'의 주소를 가져올 수 없음
}
```





## 상수의 사용

상수는 언제 사용할까?



### 변하면 안 되는 값에 상수 사용하기

상수로 변하지 않는 값에 이름을 부여하면 매번 값을 쓰지않고 편리하게 이용할 수 있습니다.

예를들어 원주율은 3.141592....로 고적된 숫자입니다.

여러번 사용한다면 너무나 귀찮은 반복작업일수 있습니다.

혹시나 값으로 사용하여 실수로 변경하면 계산값에 문제가 생길수도 있습니다.

이럴경우 상수로 사용하면 편합니다.

```go
package main

import (
	"fmt"
	"math"
)

func main() {
	const Pi float64 = 3.141592
	radius := 5.0
	fmt.Printf("원주율: %f\n", Pi)
  
  // Go math.Pow 를 사용하여 제곱근을 구할수 있습니다.
	fmt.Printf("원의 넓이: %f\n", Pi*math.Pow(radius, 1.0/2.0))
}
```



### 코드값으로 사용하기

상수를 코드값으로 사용할 수 있습니다.

코드 값이란 어떤 숫자에 의미를 부여 하는것을 말합니다.

컴퓨터에서 코드값은 매우 다양한다 예를들어 ASCII 문자 코드에서 'A' = 65입니다.

또는 Http 통신에서 404는 NOT FOUND의 의미이기도 합니다.

마찬가지로 프로그래밍에서도 이러한 코드를 사용해야 하는 경우가 많습니다.



### iota로 간편하게 열거값 사용하기

코드값으로 사용하기 때문에 값이 그냥 1, 2, 3 ... 처럼 1씩 증가 하도록 정의할때 `iota` 키워드를 사용하면 편리합니다.

다음 상수에 단지 1씩 증가하기 위한 코드를 `iota`를 사용하여 선언하겠습니다.

```go
package main

import (
	"fmt"
)

const (
	Red  = iota // 0
	Blue = iota // 1
	Gray = iota // 2
)

func main() {
	fmt.Println(Red)
	fmt.Println(Blue)
	fmt.Println(Gray)
}

// 결과값
// 0
// 1
// 2
```

>`iota` 라는 말은 그리스 알파벳의 9번째 글자로, 아주 작은 양을 뜻한다고 합니다.



위처럼 상수 선언을 소괄호로 묶고 이를 벗어나면 iota는 초기화 (*0부터 다시 시작*) 됩니다.

만약 첫번째 값과 같은 규칙이 반복된다면 iota를 생략 할 수 있습니다.

```go
const (
	Red  = iota + 1 // 1
	Blue            // 2
	Gray            // 3
)
```



다음과 같이 사용할수도 있습니다.

```go
const (
  // << 연산자는 비트를 왼쪽으로 이동합니다.
  // <<= 연산자도 있는데 비트를 왼쪽으로 이동후 대입 (a <<= 1) 등으로 사용됩니다.
	C1 uint = 1 << iota // 1
	C2                  // 2
	C3                  // 4
)
```



## 타입이 없는 상수

상수에 타입을 지정하지 않을수 있습니다.

이때는 단지 값으로만 사용됩니다.

```go
package main

import "fmt"

func main() {
	const PI = 3.14
	var pi2 = PI // float64 타입으로 자동 변환
	fmt.Println(PI * 100)
	fmt.Println(pi2 * 100)
}

// 결과 : 314
// 결과 : 314
```

타입이 없는 상수는 변수에 복사될 때 타입이 정해지기 때문에 여러 타입에 사용되는 상숫값을 사용 할 때 편리합니다.





## 상수와 리터럴

컴퓨터에서 리터럴이란 고정된 값, 값 자체로 쓰인 문구라고 볼수 있습니다.

```go
var str string = "Hello World"
var i int = 0
i = 30
```

위의 값들 자체는 ( "Hello World" , 0, 30 ) 고정된 값 자체로 쓰이기 때문에 이런 문구가 바로 리터럴 입니다.

Go언어에서 상수는 리터럴과 같이 취급합니다.

그래서 컴파일될 때 상수는 리터럴로 변환되어 실행 파일에 쓰입니다.



상수표현식 역시 컴파일 타입에 실제 결괏값을 리터럴로 변환하기 때문에 상수 표현식 계산에 CPU 자원을 사용하지 않습니다.

```go
	const PI = 3.14
	var a int = PI * 100 
  // 이때 위 구문은 컴파일 타입에 아래와같이 변환된다.
	var a int = 314
```

상수의 메모리 주솟값에 접근할 수 없는 이유 역시 컴파일 타임에 리터럴로 전환되어서

실행파일에 값 형태로 쓰이기 때문입니다.

그래서 동적 할당 메모리 영역을 사용하지 않습니다.