# 연산자





## 연산자

Go에서 연산은 비교적 다른 프로그래밍과 같습니다.

하지만 몇가지 주의 해야할점이 있습니다.

Go에서는 변수에 타입을 지정해 놓기때문에 숫자 계산시 다음과 같은 오류가 날 수 있습니다.

### 정수 오버플로

```go
var x int8 = 127

fmt.Println(x < x+1)
fmt.Println(x)
fmt.Println(x + 1)

// 결과값 : false
// 결과값 : 127
// 결과값 : -128
```

부호가 있는 정수에서 최상위 비트는 부호를 뜻합니다. 

*0 : 양수 1 : 음수*

여기서 1을 더하게 되면 비트 연산에 따라 - 부호의 제일 아랫값으로 변하게됩니다.



### 정수 언더플로

정수 오버플로에 반대로 이번에는 음의 정수에서 나타날 수 있습니다.

```go
var x int8 = -128

fmt.Println(x > x-1)
fmt.Println(x)
fmt.Println(x - 1)

// 결과값 : false
// 결과값 : -128
// 결과값 : 127
```



### Float 비교연산

다음과 같은 경우에 소수에서 == 연산이 오류가 날 수 있습니다.

```go
var a, b, c = 0.1, 0.2, 0.3

fmt.Println(a+b == c)
fmt.Println(a + b)

// 결과값 : false
// 결과값 : 0.30000000000000004
```

이경우는 float64가 가지고 있는 표현방식에서 차이가 발생합니다.

컴퓨터에서 실수값을 표현할때는 지수부와 소수부를 나누어 표현합니다.

그리고 컴퓨터는 지수부와 소수부를 10진수가 아닌 2진수로 표현을 하게됩니다.

그래서 10진수 실수를 정확하게 표현하기 어려운 문제가 있습니다.

굉장히 복잡한 계산을 하여(*머리아픈 계산식은 생략!*) 0.376을 이진수 체계로 표현한다고해도 절대 0.376으로 표현할수 없습니다.

대신 이런식으로 근사값으로 표현(0.376은 0.37599998712539...)을 하게됩니다. 

0.3또한 정확한 2진수 체계로 표현을 할수 없기때문에 우리는 이런식으로 작은 오차를 무시하도록합니다.

Go의 함수중 하나인 `Nextafter()` 를 이용합니다.

```go
package main

import (
	"fmt"
	"math"
)

func equal(a, b float64) bool {
	return math.Nextafter(a, b) == b
}

func main() {
	var a, b, c = 0.1, 0.2, 0.3

	fmt.Println(equal(a+b, c))
	fmt.Println(a + b)
}


// 결과값 : true
// 결과값 : 0.30000000000000004

```

`Nextafter()` 함수는 float64 타입 두개를 받아서 타입 하나를 반환합니다.

```go
func Nextafter(x, y float64) (r float64)
```

이 함수의 동작은 x에서 y를 향해 1비트만 조정한 값을 반환합니다.

만약 x 가 y 보다 작다면 x에서 1비트 만큼 증가시키고 그렇지 않으면 x에서 1비트 감소시킨 값을 반환합니다.

즉, 가장 작은 오차만큼 y를 향해 더하거나 빼줍니다.

소수점 몇번째 자리를 무시할거냐에 대한 사항은 모든 상황에 따라 달라지기 때문에

비교하는 숫자의 가장 마지막(*가장 작은단위*)를 비교해주면 됩니다.



하지만 이 방법 역시 작은 오차를 무시하는것 뿐이지 금융 프로그램이라면 

math/big 패키지에서 제공하는 Float객체를 사용해야합니다.

```go
package main

import (
	"fmt"
	"math/big"
)

func main() {
	a, _ := new(big.Float).SetString("0.1")
	b, _ := new(big.Float).SetString("0.2")
	c, _ := new(big.Float).SetString("0.3")

	fmt.Println(new(big.Float).Add(a, b))        // add 를사용하여 더하기
	fmt.Println(c.Cmp(new(big.Float).Add(a, b))) // compare 를 사용하여 계산
}

// * x.Cmp(y) 는 x 값이 작을경우 -1, x와 y가 같을경우 0, x 값이 클경우 1 을 반환합니다.

// 결과값 : 0.3
// 결과값 : 0

```



### Go 에서 사용하는 특별한 연산자

Go에서는 다른 함수와 같이 연산자들을 사용할 수 있습니다.

예를들어 `a++`,`a--` 등이 있습니다.

이런식으로도 사용이 가능합니다.

`a += 1`,`a -= 1`, `a *= 3`, `a %= 2`

많은 활용이 가능하지만 Go에서 가지고 있는 몇가지 특별한 연산자를 소개합니다.

| 연산자 | 설명                                                        |
| ------ | ----------------------------------------------------------- |
| []     | 배열 요소에 접근할 때 사용합니다.                           |
| .      | 구조체나 패키지 요서 접근할 때 사용합니다.                  |
| &      | 변수의 메모리 주소값을 반환합니다.                          |
| *      | 포인터 변수가 가리키는 메모리 주소에 접근합니다.            |
| ...    | 슬라이스 요소들에 접근하거나 가변 인수를 만들때 사용합니다. |
| :      | 배열의 일부분을 집어올 때 사용합니다.                       |
| <-     | 채널에서 값을 빼거나 넣을때 사용합니다.                     |



### 우선순위

Go에서는 연산자의 우선순위가 있습니다.

우선 순위가 높을수록 먼저 계산됩니다.

우선 순위가 같이면 좌측부터 우측으로 연산됩니다.

| 우선 순위 | 연산자                 |
| --------- | ---------------------- |
| 5         | *  /  %  <<  >>  &  &^ |
| 4         | +  -                   |
| 3         | ==  !=  <  <=  >  >=   |
| 2         | &&                     |
| 1         | \|\|                   |
