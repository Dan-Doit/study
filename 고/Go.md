# Go lang 스터디

---



## Go 언어의 관한 내용을 정리합니다.



정적언어는 각 운영체제와 CPU의 환경에 따라 컴파일러의 변환을 다르게 합니다.

Go 언어 또한 이러한 정적언어의 성격을 따라가지만 몇가지 옵션을 주어 쉽게 컴파일이 가능합니다.

2가지 옵션이 주인데 `GOOS ` OS 와 `GOARCH ` 아키텍쳐 설정입니다.

```bash
# 다음 명령어로 Go에서 컴파일 가능한 옵션들을 볼수 있습니다.
$ go tool dist list
```



```bash
# 빌드시 옵션을 줄 수 있다.
$ GOOS=linux GOARCH=amd64 go build
```

---

<br>



## main



### 메인 함수는 Go에서 정말 특별한 패키지이자 함수입니다.

고 언어의 모든 코드는 반드시 패키지(`package`)로 시작을 해야합니다. 

Go에서 `main` 패키지는 프로그램의 시작점을 포함하는 특별한 패키지 입니다.

`main` 패키지에서는 `main( )` 함수가 없다면 `main` 패키지를 사용할 수 없습니다.

```go
package main

import "fmt"

func main() {
	fmt.Println("Hello World")
}

```

---

<br>



## import



### Go 에서는 다른 패키지를 불러와야 할때 import를 사용합니다.

`fmt` 표준 입출력 장치를 다루는 내장 패키지입니다.

---

<br>



## func



### Go에서 함수를 선언하는 방식입니다.

func `이름` ( 파라미터 ) { 본문의 시작 } 형식입니다.

```go
// 함수를 적을때는 이렇게 사용합니다.
func hello() {
	fmt.Println("Say Hello")
}
```

---

<br>



## Go의 변수



### Go는 정적 언어이기 때문에 변수에 크기를 할당해 주어야 합니다.

```go
var number int = 100
```

크기의 종류는 다음과 같습니다.

| 자료형     | 저장범위                                               | 설명                                                   |
| ---------- | ------------------------------------------------------ | ------------------------------------------------------ |
| uint8      | 0 ~ 255                                                | 부호 없는 8비트 정수형                                 |
| uint16     | 0 ~ 65,535                                             | 부호 없는 16비트 정수형                                |
| unit32     | 0 ~ 4,294,967,295                                      | 부호 없는 32비트 정수형                                |
| uint64     | 0 ~ 18,446,744,073,709,551,615                         | 부호 없는 64비트 정수형                                |
| uint       |                                                        | 32비트 시스템에서는 uint32, 64비트 시스템에서는 uint64 |
| int8       | -128 ~ 127                                             | 부호 있는 8비트 정수형                                 |
| int16      | -32,768 ~ 32,767                                       | 부호 있는 16비트 정수형                                |
| int32      | -2,147,483,648 ~ 2,147,483,647                         | 부호 있는 32비트 정수형                                |
| int64      | -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 | 부호 있는 64비트 정수형                                |
| int        |                                                        | 32비트 시스템에서는 int32, 64비트 시스템에서는 int64   |
| float32    |                                                        | IEEE-754 32비트 부동소수점, 7자리 정밀도               |
| float64    |                                                        | IEEE-754 64비트 부동소수점, 12자리 정밀도              |
| complex64  |                                                        | float32 크기의 실수부와 허수부로 구성된 복소수         |
| complex128 |                                                        | float64 크기의 실수부와 허수부로 구성된 복소수         |
| uintptr    |                                                        | uint와 같은 크기를 갖는 포인터형                       |
| bool       |                                                        | 참, 거짓을 표현하기 위한 8비트 자료형                  |
| byte       |                                                        | 8비트 자료형                                           |
| rune       |                                                        | 유니코드 저장을 위한 자료형, 크기는 int32와 동일       |
| string     |                                                        | 문자열을 저장하기 위한 자료형                          |



### 변수 선언은 일반적으로 `var` 를 사용하지만 다음과 같이 사용할수 있습니다.

```go
package main

import "fmt"

func main() {
	var a int = 1
	var b int   // 변수를 초기화 해주지 않으면 기본으로 0으로 설정됩니다.
	var c = 3
	d := 4

	fmt.Println(a, b, c, d)
}

// 결과 
// 1 0 3 4
 
```



### 다음은 모든 변수의 초기값 입니다.

| 타입                                    | 기본값                                               |
| --------------------------------------- | ---------------------------------------------------- |
| 모든 정수 타입 (int, byte ...)          | 0                                                    |
| 모든 실수 타입 (float32, complex64 ...) | 0.0                                                  |
| 불리언 타입(bool)                       | false                                                |
| 문자열 타입(string)                     | ""                                                   |
| 그외 타입                               | nil (정의되지 않은 메모리 주소를 나타내는 Go 키워드) |



### 숫자의 기본 타입

타입을 생략하면 우변의 타입으로 좌변의 타입이 지정됩니다. 만약 우변이 숫자이면 기본타입으로 결정 됩니다.

정수는 int, 실수는 float64가 기본 타입입니다.



### 선언 대입문 :=

말 그대로 선언과 대입을 한번에 하는 구문입니다. 선언 대입문을 사용하면 var 키워드 타입을 생략할 수 있습니다.

```go
var b = 3.141519      // float64 자동 지정
c := 365 							// int 자동 지정
s := "Jerry And Tom"  // string 자동 지정
```

---

<br>



## 타입 변환

프로그래밍을 구분할때 타입 검사를 하는가 안 하는가에 따라 강타입 언어와 약타입 언어로 구분됩니다.

Go는 그 중 가장 강하게 타입 검사를 하는 최강 타입 언어입니다.

```go
	a := 3
	b := 3.3
	
	// 잘못된 연산: a * b (일치하지 않는 타입 int와(과) float64)
	fmt.Println(a * b)
	
	var c int64 = 9999
	var d int = 8888
	
	// 잘못된 연산: c * d (일치하지 않는 타입 int64와(과) int)
	fmt.Println(c * d)
	
	var e string = "365"
	var f int = 32

	// 잘못된 연산: e * f (일치하지 않는 타입 string와(과) int)
	fmt.Println(e + f)
```



 그래서 변환을 해주는 작업이 필요합니다.

그리고 변환시 주의 해야 할점을 항상 염두해야 합니다.

```go
	a := 3
	b := 3.3

	fmt.Println(float64(a) * b)

	var c int64 = 9999
	var d int = 8888

	fmt.Println(int(c) * d)

	var e string = "365"
	var f int = 32

	fmt.Println(e + string(f))

	var g = 5.9332

	// 주의!! float 타입을 정수형으로 변환시 소수점 이하가 없어(반올림 x 버림 o)집니다.
	fmt.Println(int(g))

	var h int16 = 3456

	// 주의!! 큰 타입에서 작은 타입으로 변환시 상위 1byte가 없어졌기 때문에 - 처리됩니다.
	fmt.Println(int8(h))

	// 결과
 	// 9.899999999999999
	// 88871112
	// 365 
	// 5
	// -128
```



>### Go에서 음수 표현
>
>숫자 `15`를 1byte 2진수로 표현하면 다음과 같습니다.
>
>```bash
>0   0 0 0 1 1 1 1
>```
>
>그럼 음수 `-15`를 표현하는 방법은 다음과 같을 까요?
>
>```bash
>1   0 0 0 1 1 1 1
>```
>
>정답은 그렇지 않습니다.
>
>왜냐하면 단순히 최상위 비트가 1 이냐 0 이냐에 따라서 판단을 하게 되면 +0 과 -0 이라는 이상한 개념이 생기기 때문입니다.
>
>게다가 표현을 할 수 있는 숫자가 하나 줄어들어 낭비가 발생하기 때문에 컴퓨터에서는 절댓값의 2의 보수로 표현합니다.
>
>**2의 보수**를 만드는 방법은 **모든 비트의 0을 1로, 1을 0으로 만든뒤 1을 더하면** 됩니다.
>
>```bash
>0   0 0 0 1 1 1 1
>
># 비트 반전
>1   1 1 1 0 0 0 0
>
># 1 더하기 (-15 가 표현되었습니다.)
>1   1 1 1 0 0 0 1
>```

>### Go에서 실수 표현
>
>Go에서는 실수 표현을 IEEE-754 표준을 따라 실수를 표현합니다.
>
>예를들어 1024.234 는 0.1024234 * 10^4 로 나타낼 수도 있고, 0.1024234e+e4라고 쓰기도 합니다.
>
>이런 원칙에 따라 어느정도 표현의 한계가 있는데요
>
>| 타입    | 최솟값                  | 최댓값                 | 소수부 |
>| ------- | ----------------------- | ---------------------- | ------ |
>| float32 | 1.175494351e-38         | 3.402823466e38         | 7자리  |
>| float62 | 2.2250738585072014e-308 | 1.7976931348623158e308 | 15자리 |
>
>이런 방식으로 Go는 실수값을 표현할때 정확한 값이 아닌 타입이 허용하는 범위에서 가장 가까운 근삿값으로 표현하게 됩니다.
>
>그래서 가끔 계산에 오류가 생길수 있습니다.
>
>```go
>package main
>
>import "fmt"
>
>func main() {
>	var a float32 = 1234.523
>	var b float32 = 3456.123
>	var result float32
>	for i := 0; i < 100; i++ {
>		result = a * b
>    	
>	}
>	fmt.Println(result)
>}
>
>// 결과값
>// 4.266663e+06
>```
>
>정확한 결과는 4266663.334329 이지만 float32의 7자리 제한에 걸려 4266663이 됩니다.
>
>이는 **계산이 거듭될수록 큰 차이를 야기하며** 금융이나 회계등 정확한 숫자 값을 요구하는 프로젝트에서는
>
>**반드시 숫자타입의 사용에 충분한 고려와 주의**가 필요합니다.

---

<br>



## 표준 입출력



### 표준 출력

표준 입출력 기능을 Go에서는 fmt 패키지에서 제공합니다.

```go
package main

import "fmt"

func main() {
	var a = 10
	var b = 20
	var f = 32212322213.872

	fmt.Print("a: ", a, "b: ", b)
	fmt.Println("a: ", a, "b: ", b, "f: ", f)
	fmt.Printf("a: %d b: %d f:%f\n", a, b, f)
}
// 함수를 적을때는 이렇게 사용합니다.
func hello() {
	fmt.Println("Say Hello")
}

// 결과값
// a: 10b: 20a:  10 b:  20 f:  3.2212322213872e+10
// a: 10 b: 20 f:32212322213.872002
```

위에서 실수 값이 한쪽은 e로 나오고 두번째값은 소수점 6자리 까지 표현되는 이유는 

기본적으로 fmt에서 실수값의 기본서석이 %f 가 아닌 %g형식이기 때문입니다.

printf의 서식은 많은 종류가 있지만 일단은 자주쓰이는 다음의 종류만 알아도 큰 도움이 됩니다.

| 구분 | 설명                                                         |
| ---- | ------------------------------------------------------------ |
| %v   | 데이터 타입에 맞춰서 기본 형태로 출력합니다.                 |
| %d   | 10진수 정수 값으로 출력합니다.                               |
| %f   | 지수 형태가 아닌 실숫값을 그대로 출력합니다.                 |
| %s   | 문자열을 출력합니다.                                         |
| %g   | 값이 큰 실숫값은 지수 형태로 출력하고(%e), 작은 실숫값은 실숫값 그대로(%f) 출력합니다. |
| %p   | 메모리 주소인 포인터 값을 출력합니다.                        |
| %T   | 데이터 타입을 출력합니다.                                    |
| %t   | true/false로 된 불리언값을 출력합니다.                       |



다음의 기능으로 간격과 정렬을 하여 출력할 수 있습니다.

```go
package main

import "fmt"

func main() {
	var a = 333.33333
	var b = 3.14

  // %[공백을 채울값 없을시 공백][공백의 최솟값].[소수점 표현 자리수 기본 6][형식]
  // f와 g의 소수점 자리수는 표현하는 소수점과 총 숫자라는 차이가 있습니다.
  
	fmt.Printf("%08.2f\n", a) // 최소 공백 8 빈값을 0을 채움, 소수점 이하 2자리
	fmt.Printf("%08.2g\n", a) // 최소 공백 8 빈값을 0을 채움, 총 숫자 2자리
	fmt.Printf("%8.5g\n", a)  // 최소 공백 8 빈값을 공백을 채움, 총 숫자 5자리
	fmt.Printf("%f\n", b)     // 소수점 이하 6자리
}

// 출력값
// 00333.33
// 03.3e+02
//  333.33
// 3.140000


```



## 표준 입력

표준 입력 장치는 일반적으로 표준 입력을 변경하지 않았다면 키보다가 표준 입력 장치입니다.

Fmt 패키지에서는 표준 입력 으로부터 입력받는 `Scan()`,`Scanf()`,`Scanln()`이 있습니다.



### Scan

Scan 은 기본적으로 공백과 `enter` 를 기준으로 스플릿이 되어 변수에 저장을 합니다.

파라미터로 변수의 주소 값을 받습니다.

```go
package main

import "fmt"

func main() {
	var a, b int
  
	// n은 받은 변수의 인덱스 err 는 에러가 저장됩니다.
  // &는 주소값을 의미합니다.
	n, err := fmt.Scan(&a, &b)
	if err != nil {
		fmt.Println(n, err)
	} else {
		fmt.Println(n, a, b)
	}
}

// 입력값 : 1 2
// 결과값 : 2 1 2

// 입력값 : 한글 1
// 결과값 : 0 expected integer

// 입력값 : 1 한글
// 결과값 : 1 expected integer

// 입력값 : 1 
// 입력값 : 2
// 결과값 : 2 1 2
```



### Scanln

Scanln은 반드시 종료를 `enter` 마무리가 되어야 한다는 점입니다.

파라미터로 변수의 주소 값을 받습니다.

```go
package main

import "fmt"

func main() {
	var a, b int

	n, err := fmt.Scanln(&a, &b)
	if err != nil {
		fmt.Println(n, err)
	} else {
		fmt.Println(n, a, b)
	}
}

// 입력값 : 1 2
// 결과값 : 2 1 2

// 입력값 : 1
// 입력값 : (enter)
// 결과값 : 1 unexpected newline
```



### Scanf

Scanf는 서식에 맞는 입력을 받습니다.

파라미터로 서식과 주소 값을 받습니다.

```go
package main

import "fmt"

func main() {
	var a, b int

	n, err := fmt.Scanf("%d %d\n", &a, &b)
	if err != nil {
		fmt.Println(n, err)
	} else {
		fmt.Println(n, a, b)
	}
}

// 입력값 : 1 2
// 결과값 : 2 1 2

// 입력값 : 1
// 입력값 : (enter)
// 결과값 : 1 newline in input does not match format

```



>### 키보드 입력과 Scan( ) 함수의 동작원리
>
>사용자가 표준 입력 장치로 입력을 하면 입력 데이터는 컴퓨터 내부에서 **표준 입력스트림** 이라는 메모리 공간에 임시 저장이 됩니다.
>
>Scan( ) 함수들은 그 표준 입력 스트임에서 값을 읽어서 입력값을 처리합니다.
>
>
>동작 원리는 다음과 같습니다.
>
>```go
>var a, b int
>fmt.Scanln(&a, &b)
>```
>
>위와 같이 두 int 타입을 입력 받을때 사용자가 적은 내용은 다음과 같이 입력 스트림에 저장이 됩니다.
>
>```bash
># 입력
>Hello 1 (enter)
>
># 저장
>/n 1  o l l e H 
>```
>
>이때 가장 먼저 입력한 데이터 부터 읽어오기 깨문에 데이터가 거꾸로 저장이 됩니다.
>
>이런 방식을 컴퓨터 공학에서 **FIFO (first in first out) - Queue** 자료 구조형을 갖게 됩니다.
>
>표준입력 스트림은 위와같이 FIFO 구조를 가지고 있습니다.
>
>표준 입력스트림은 위에 저장된 데이터에서 한글자를 가져옵니다.
>
>```bash
># 가져온 데이터
>H
>
># 데이터 삽입 (예를 든 형식입니다.)
>var a int = 'H' # err : 숫자 형식이 아님
>```
>
>위와 같이 에러가 생기면 표준 스트림에는 아직 `\n 1   o l l e` 라는 문자가 남아있습니다.
>
>이러한 방식으로 다음글자인 e 를 불러와 에러를 발생합니다.
>
>이작업은 스트림에 데이터가 없을때까지 반복이 됩니다.
>
>그래서 여러번 Scan( ) 함수를 호출할때는 표준 입력 스트림을 비워주어야 합니다.
>
>```go
>package main
>
>import (
>	"bufio"
>	"fmt"
>	"os"
>)
>
>func main() {
>	stdin := bufio.NewReader(os.Stdin) // 표준 입력을 받는 객체
>
>	var a, b int
>
>	n, err := fmt.Scanln(&a, &b)
>
>	if err != nil {
>		fmt.Println(err)  // 에러 출력
>		stdin.ReadString('\n')  // 표준 입력 스트림 지우기
>	} else {
>		fmt.Println(n, a, b)
>	}
>}
>```
>
>표준 입력스트림에서 한 줄을 읽어오는 bufio, os 등의 패키지를 사용합니다.
>
>Bufio는 입력 스트림으로부터 한 줄을 읽는 Reader 객체를 사용합니다.
>
>```go
>func NewReader(rd io.Reader) *Reader
>```
>
>Reader 객체를 만들어 주기 위해서 우리는 code에서 `os.Stdin` 을 사용하였습니다.
>
>줄바꿈 문자가 나올 때까지 우리는 읽습니다. 이렇게 하면 표준 입력 스트림이 비워집니다.

---

<br>



