## 캐시

웹 캐시는 자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP 장치이다.

웹 요청이 캐시에 도착했을 때, 캐시된 로컬 사본이 존재하면, 그 문서는 원 서버가 아니라 캐시로 부터 제공된다.

캐시는 불필요한 데이터 전송을 줄이고, 비용을 줄이며, 병목을 줄여주고, 원서버의 요청도 줄여준다.

또한 캐시는 먼 거리로 인한 지연도 줄여줄수 있다.



### 불필요한 데이터 전송

복수의 클라이언트가 자주 쓰이는 원 서버 페이지에 접근할때, 서버는 같은 문서를 클라이언트에게 전송한다.

이 불필요한 데이터 전송은 값비싼 네트워크 대역폭을 잡아먹으며, 전송을 느리게 한다.

캐시를 이용하면 한번 캐싱된 데이터에 대해 원 서버가 감당해야할 트래픽의 낭비가 줄어들게된다.



### 대역폭 병목

캐시는 네트워크 병목을 줄여준다.

많은 네트워크가 원격서버보다 로컬 네트워크 클라이언트에 더 넓은 대역폭을 제공한다.

클라이언트들이 서버에 접근할 때의 속도는 그 경로에 있는 가장 느린 네트워크의 속도와 같다.

만약 클라이언트가 빠른 LAN에 있는 캐시로부터 사본을 가져온다면, 성능을 대폭 개선시킬수 있다.



### 갑작스런 요청 쇄도

캐싱은 갑작스러운 요청 쇄도에 대처하기 위해 특히 중요하다.

많은 사람들이 거의 동시에 유명 사이트에 접속할때의 트래픽급증은 네트워크와 웹 서버의 심각한 장애를 이야기합니다.



### 거리로 인한 지연

모든 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킵니다.

그리고 클라이언트 서버 사이에 라우터가 그다지 많지 않더라도 빛의 속도는 그 자체가 유의미한 지연을 유발시킨다.

기계실 근처에 캐시를 설치하면 수천 킬로미터를 수십미터로 줄일수 있다.



### 적중과 부적중

캐시가 모든 세상의 문서의 사본을 저장하지는 않는다.

캐시에 도착하였을때 그에 대응하는 사본이 있으면 이를 전송한다. 이를 적중이라고 하고 반대를 부적중이라고 한다.

- 적중률

  캐시가 요청을 처리하는 비율을 캐시 적중률, 혹은 문서 적중률이라고 부리가도 한다.

  이 적중률은 0~1 사이지만 보통 백분률로 나타내고 100%는 모든 요청이 캐시적중 사본을 가져온 경우를 의미한다.

- 바이트 적중률

  문서들이 모두 같은 크기인 것은 아니기 때문에 문서 적중률이 모든것을 말하는것은 아니다.

  몇몇 큰 객체는 덜 접근되지만 그 크기 때문에 전체 트래픽에는 더 크게 기여한다.

  어떤 사람들은 바이트 단위 적중률 측정을 선호한다.

  특히 트래픽의 모든 바이트에 요금을 매기려 하는경우 더 그렇다.

- 적중과 부적중의 구별

  불행하게도 HTTP는 클라이언트에게 응답이 캐시 적중이였는지 아니면 원 서버 접근인지 말해주지 않는다.

  두 경우 모두 응답코드는 200 OK가 된다.

  어떤 상용 프록시 캐시는 캐시에 무슨일이 일어났는지 설명하기 위해 Via 헤더에 추가정보를 붙인다.

  클라이언트가 응답이 캐시에서 왔는지 알아내는 방법은 Date 헤더를 이용하면된다.

  응답의 Date 헤더 값을 현재 시각과 비교하여, 응답의 생성일이 더 오래되었다면 클라이언트는 응답이 캐시된 것임을 알수있다.

  ![image-20220716113144051](6장 캐시.assets/image-20220716113144051.png) 

- 캐시망 콘텐츠 라우팅, 피어링

  몇몇 네트워크 아키텍처는 단순한 캐시 계층 대신 복잡한 캐시망을 만든다.

  캐시망안에서의 콘텐츠 라우팅을 위해 설계된 캐시들은 다음에 나열된 일을 모두 할수 있을것이다.

  - URL에 근거하여, 부모 캐시와 원 서버중 하나를 동적으로 선택한다.

  - URL에 근거하여 특정 부모 캐시를 동적으로 선택한다.

  - 부모 캐시에게 가기전에, 캐시된 사본을 로컬에서 찾는다.

  - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되,
    그들의 캐시를 통한 인터넷 트랜짓은 허용하지 않는다.

    >트랜짓(Internet Transit) 이란 트래픽이 다른 네트워크로 건너가는것을 의미합니다.

    상호간의 이득을 위해 선택적인 피어링을 지원하는 캐시는 형제캐시라 불린다.

    하지만 HTTP에서 이를 지원하지 않기때문에, 사람들은 이를 위한 프로토콜(ICP, HTCP)을 확장하였다.





### 캐시처리

오늘날의 상용 프록시 캐시는 꽤 복잡하다.

매우 고성능이면서도 HTTP와 그 외 다른 기술의 고급 기능을 지원하도록 만들어졌다.

미묘한 구석이 있지만 웹 캐시의 기본적인 동작은 대개 단순하다.

1. 요청 받기 - 캐시는 네트워크로부터 도착한 요청 메시지를 읽는다.
2. 파싱 - 캐시는 메시지를 파싱하여 URL과 헤더들을 추출한다.
3. 검색 - 캐시는 로컬 복사본이 있는지 검사하고, 사본이 없다면 사본을 받아오고 로컬에 저장한다.
4. 신선도 검사 - 캐시는 캐시된 사본이 충분히 신선한지 검사하고, 신선하지 않다면 변경사항이 있는지 서버에 물어본다.
5. 응답 생성 - 캐시는 새로운 헤더와 캐시된 본문으로 응답 메시지를 만든다.
6. 발송 - 캐시는 네트워크를 통해 응답을 클라이언트에게 돌려준다.
7. 로깅 - 선택적으로, 캐시는 로그파일에 트랜젝션에 대해 서술한 로그 하나를 남긴다.



### 신선도 유지

캐시된 사본 모두가 서버의 문서와 항상 일치하는것은 아니다.

결국 문서들은 시간에 따라 변경된다.

HTTP는 어떤 캐시가 사본을 갖고있는지 서버가 디억하지 않더라도, 캐시된 사본이 서버와 충분히 일치하도록 유지하는 단순한 매커니즘이 있다.

- 문서완료

  HTTP는 Cache-Conrol과 Expires 라는 특별한 헤더를 이용해 원서버가 각 문서에 유효한 기간을 붙일수 있게 해준다.

  캐시 문서가 만료되기 전에, 캐시는 필요하다면 서버와접촉 없이 사본을 제공할수 있다.

- 유효기간과 나이

  서버는 응답 본문과 함께하는, HTTP/1.0+ Expires 나 

  HTTP/1.1 Cache-Control: max-age 응답 헤더를 이용해 유효기간을 명시한다.

  | 헤더                   |                                                              |
  | ---------------------- | ------------------------------------------------------------ |
  | Cache-Control: max-age | Max-age 값은 문서의 최대 나이를 정의한다. 최대 나이는 문서가 처음 생성된 이후부터,<br />더이상 신선하지 않다고 간주될 때 까지의 경과한 시간의 합법적인 초단위이다. |
  | Expires                | 절대 유효기간이다. 만약 유효기간이 경돠되면, 그문서는 더 이상 신선하지 않다. |

- 조건부 메서드와의 재검사

  HTTP의 조건부 메서드는 재검사를 효율적으로 만들어준다.

  HTTP캐시는 서버에게 '조건부 GET' 이라는 요청을 보낼 수 있도록한다.

  HTTP에는 5가지의 조건부 요청헤더가 있지만 그둘중 캐시 재검사를 할때 가장 유용한것은 다음 두가지이다.

  | 헤더                    |                                                              |
  | ----------------------- | ------------------------------------------------------------ |
  | If-Modified-Since: date | 만약 문서가 주어진 날짜 이후로 수정되었다면 요청 메서드를 처리한다.<br />캐시된 버전으로부터 콘텐츠가 변경된 경우에만 콘텐츠를 가져오기 위해 <br />Last-Modified 응답헤더와 같이 사용된다. |
  | If-None-Match: etag     | 서버는 문서에 대한 일련번호와 같이 동작하는 특별한 태그(ETag) 을 제공할수 있다.<br />이 헤더는 태그가 서버에 있는 문서의 태그와 다를때만 요청한다. |



### 캐시 제어

HTTP는 문서가 만료되기 전까지 **얼마나 오랫동안 캐시될 수 있게 할 것인지 서버가 설정할 수 있는 여러가지 방법**을 정의한다.

- Cache-Control: no-store

  이 응답은 사실 로컬 캐시 저장소에 저장할수 있다.

  다만 먼저 서버와 재검사 하지 않고서는 캐시에서 클라이언트로 제공될 수 없을 뿐이다.

  이 헤더는 사실 "Do-Not-Serve-From-Cache-Without-Revalidation" 가 더 어울리는 이름이다.

  (재검사 없이 캐시에서 제공하지마라)

  추가적으로 Pragma: no-cache 헤더는 HTTP/1.0+와의 하위 호환성을 위해 포함되어있다.

  HTTP/1.0의 아래버전에는 이 헤더의 문장을 이해하기 위해  Pragma: no-cache 헤더를 사용한다.

- Cache-Control: no-cache

  캐시가 그 응답의 사본을 만드는 것을 금지한다.

  캐시는 보통 클라이언트에세 no-store을 전달하고 나면 객체를 삭제할것이다.

- Cache-Control: must-revalidate

  캐시의 성능을 개선하기 위해 신선하지 않은 객체를 제공되도록 설정할수 있다.

  만약 캐시가 만료 정보를 엄격하게 따르길 원한다면, 원서버는 가음과 같은 Cache-Control을 붙인다.

  ```http
  // "캐시가 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공되서는 안된다"는 의미이다.
  Cache-Control: must-revalidate
  ```

- Cache-Control: max-age

  이 헤더는 문서가 서버로 부터 갱신되고 이후로 흐른 시간이다.

  s-maxage 헤더는 max-age처럼 행동하지만 공유된 캐시에서만 적용된다.

  ```http
  // 캐시 컨트롤 age 옵션
  Cache-Control: max-age=3600
  Cache-Control: s-maxage=3600
  ```

- Expires

  **더이상 사용하지 않기를 권하는 (deprecated) 이 헤더**는 초 간위의 시간 대신 실제 만료 날짜를 명시한다.

  몇몇 서버는 문서를 이헤더를 통해 사용하지만 받아들일수 있기는 하나 생성해서는 안된다.

- 아무정보도 주지않고 캐시 스스로 방법을 결정

  만약 위의 헤더들이 포함되지 않는다면, 캐시는 경험적인 방법으로 최대 나의를 계산한다.

  어떤 알고리즘도 사용될수 있지만 계산 결과 얻은 최대 나의 값이 24시간보다 크면
  **Heuristic Expiration 경고 헤더가 응답 헤더**에 추가되어야한다.



웹 브라우저는 프록시 캐시의 신선하지 않은 콘텐츠를 강제로 갱신시켜주는 리프레시나 리로드 버튼을 갖고있다.

이 리프레시 버튼은 Cache-control 요청 헤더가 추가된 GET요청을 발생시켜서, 강제로 재검사하거나 서버로부터 콘튼츠를 무조건 가져온다.

또는 느슨한 제어를 위해 다음과 같은 Cache-Contol 헤더 옵션을 사용할수 있다.

| 헤더                                                      |                                                              |
| --------------------------------------------------------- | ------------------------------------------------------------ |
| Cache-Control: max-stale<br />Cache-Control: max-stale= s | 캐시는 신선하지 않은 문서라도 자유롭게 제공한다.<br />만약 s가 지정되면 클라이언트는 매개 변수 만큼의 시간만큼 지난 문서 까지 받아들인다.<br />**이 헤더는 규칙을 느슨하게 만든다.** |
| Cache-Control: min-fresh                                  | 클라이언트는 지금으로부터 적어도 s초 까지 신선한 문서만을 받아들인다.<br />**이 헤더는 규칙을 엄격하게 만든다.** |
| Cache-Control: max-age= s                                 | 캐시는 명시된 s초 보다 오랫동안 캐시된 문서를 반환할수 없다.<br />**이 헤더는 규칙을 엄격하게 만든다.** |
| Cache-Control: no-cache<br />Pragma: no-cache             | 이 클라이언트에 캐시된 리소스는 재검사하기 전에는 받아들일수 없다. |
| Cache-Control: no-store                                   | 이 캐시는 저장소에서 문서의 흔적은 최대한 빨리 삭제해야한다.<br />그 문서에는 민감한 정보가 포함되어있기 때문이다. |
| Cache-Control: only-if-cached                             | 클라이너트는 캐시에 들어있는 사본만을 원한다.                |

항상 주의해야할점은 인간이 가진 실수이다.

퍼블리셔가 잘못해서 유효기간을 까마득한 미래로 설정한다면 이 캐시는 그 미래가 도달되기 전까지 업데이트 되지 않는다.

심지어 유효기간을 설정하지 않아서 문서가 얼마나 오랫동안 신선할 것인지 캐시가 알아차리기 힘든경우도 있다.