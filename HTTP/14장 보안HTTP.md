# 보안 HTTP

사람들은 웹 트랜젝션을 중요한 일에 사용한다. 여기에 강력한 보안이 없다면, 사람들은 결제나 인터넷뱅킹을 사용할때 안심할 수없다.

HTTP의 보안 버전은 효율적이고, 이식성이 좋고, 관리가 쉽고 , 현실 세계의 변화에 대한 적응력또한 좋아야한다.

정부의 요청사항이나 사회의 요청사항에도 맞아야한다.



## HTTP을 안전하게 만들기

다음 사항들을 중점적으로 생각해볼 필요가 있다.

- 서버 인증 - 클라이언트는 자신이 위조된 서버가 아닌 진짜와 이야기하고 있음을 알 수 있어야한다.
- 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고 있음을 알 수 있어야한다.
- 무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야한다.
- 암호화 - 클라이언트와 서버는 도청에 대한 걱정 없이 서로 대화할수 있어야한다.
- 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 출분히 빨라야한다.
- 편재성 - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야 한다.
- 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야한다.
- 적응성 - 현재 알려진 최신의 보안 방법을 지원해야 한다.
- 사회적 생존성 - 사뢰의 문화적, 정치적 요구를 만족 시켜야한다.



### HTTPS

HTTPS는 HTTP를 안전하게 만드는 방식 중에서 가장 인기 있는 것이다.

넷스케이프 커뮤니티 주식회사에서 개척하였으며 모든 주류 브라우저와 서버에서 지원한다.

HTTPS는 모든 HTTP요청과 응답 데이터는 네트워크로 보내지기 전에 암호화된다.

![image-20220723144336225](14장 보안HTTP.assets/image-20220723144336225.png) 

어려운 인코딩 및 디코딩 작업은 대부분 SSL 라이브러리 안에서 일어나기 떄문에, 보안 HTTP를 사용하기 위해 웹 클라이언트와 서버사 프로토콜을 처리하는 로직을 크게 반영할 필요가없다.

대부분의 경우, TCP 입/출력 호출을 SSL 호출로 대체하고, 보안 정보를 설정하고 관리하기 위한 몇 가지 호출을 추가하면된다.



### 디지털 암호학

HTTPS와 SSL에서 이용되는 임호인코딩 기법에 대해 약간의 배경지식이 필요하다.

- 암호

  텍스트를 아무나 읽지 못하도록 인코딩하는 알고리즘

- 키

  암호의 동작을 변경하는 숫자로 된 매개변수

- 대칭키 암호 체계

  인코딩과 디코딩에 같은 키를 사용하는 알고리즘

  대용량 암복호화가 빠르다.

- 비대칭키 암호 체계

  인코딩과 디코딩에 다른 키를 사용하는 알고리즘

- 공개키 암호

  비밀 메시지를 전달하는 수백만 대의 컴퓨터를 쉽게 만들 수 있는 시스템

  키를 하나로 암호화 하고 개인이 가진 키로 복호화 할수있다.

  공개키는 CA가 가지고 있다.

- 디지털 서명

  메시지가 위조 혹은 변조되지 않았음을 임증하는 체크섬

- 디지털 인증서

  신회할 만한 조직에 의해 서명되고 검증된 신원 확인 정보



### 암호

암호법은 암호라 불리는 비밀 코드에 기반한다.

암호란 메시지를 인코딩하는 어떤 특정한 방법과 나중에 그 비밀 메시지를 디코딩하는 방법이다.

인코딩되기 전의 원본 메시지는 흔히 텍스트 혹은 평문이라고 불린다.

암호가 적용되어 코딩된 메시지는 보통 암호문이라고 불린다.



### 디지털 암호

- 속도 및 기능에 대한 기계장치의 한계에서 벗어남으로써, 복잡한 인코딩과 디코딩 알고리즘이 가능해졌다.
- 매우 큰 키를 지원하는것이 가능해져서, 단일 암호 알고리즘으로 키의 값마다 다른 수조개의 가상 암호 알고리즘을 만들어 낼 수 있게 되었다.



### 대칭키 암호법

많은 디지털 암호 알고리즘은 대칭키 암호라 불리는데, 홰냐하면 그들이 인코딩을 할 때 사용하는 키가 디코딩을 할 때와 같기 때문이다.

발송자와 수신자 모두 통신을 위해 비밀키를 똑같이 공유할 필요가 있다.

잘 알려진 대칭키 암로 알고리즘으로는 **DES, Triple-DES, RC2, RC4** 등이 있다.

대칭키 암호의 단점중 하나는 발송자와 수신자가 서로 대화하려면 둘 다 공유키를 가져야 한다는 것이다.



### 키 길이와 열거 공격

비밀키가 누설되면 안 된다는 것은 매우 중요하다.

대부분의 경우 알고리즘은 공개적으로 알려졌으므로 키만이 유일한 비밀이다.

여기서 해커가 무차별적으로 모든 키 값을 대입해보는 공격을 열거 공격이라고 한다.

대칭키 암호에서는 보통은 모든 키값이 유효하다. 8비트, 40비트, 128비트등등

평범한 대칭키 암호에서 40비트는 작고 중요하지 않은 업무에는 충분하다고 할수 있다.

그러나 초당 수십억 번의 계산이 다능한 오늘날의 워크 스테이션에서는 쉽게 깨질수 있다.

이에 반해 128비트 매우 강력한것으로 알려져있다.

![image-20220723150148019](14장 보안HTTP.assets/image-20220723150148019.png) 





## 공개키 암호법

한 쌍의 호스트가 하나의 인코딩/디코딩 키를 사용하는 대신, 공개키 암호 방식은 두개의 비 대칭키를 사용한다.

하나는 호스트 메시지를 인코딩 하기위한 것이며, 다른 하나는 그 호스트의 메시지를 디코딩하기 위한 것이다.

인코딩 키는 모두를 위해 공개되어 있다. 하지만 호스트만이 개인 키를 알고있다.

- 노드는 자신의 인코딩 키를 공개적으로 배포할수 있다.

  이제 배시지를 노드에게 보내고자 하는 누구나 똑같고 잘 알려진 공개키를 사용할 수 있다.

  각 호스트마다 누구나 사용할 수 있는 인코딩 키가 할당되어 있기 때문에, 공개키 암호 방식은 대칭키의 쌍이 폭발적으로 증가하는 것을 피할수 있다.



### RSA

공개키 비대칭 암호의 과제는 악당이 아래 내용을 알고 있다 해도 비밀인 개인 키를 계산할 수 없다는 것을 확신시켜주는 것이다.

- 공개키
- 가로채서 얻은 암호문의 일부
- 메시지와 그것을 암호화한 암호문

이 모든 요구를 만족하는 공개키 암호 체계중 유명한 하나는 MIT 에서 발명되고 이어서 RSA 데이터 시큐리티에서 사용화된 RSA 알고리즘이다.

그리고 RSA 구현의 소스코드까지 주어졌다 하더라도 암호를 크래킹하여 해당하는 개인 키를 찾아내는 것은 컴퓨터과학의 모든 분야에서 가장 어려문 문제중 하나로 알려진 큰 소수를 계산하는 문제만큼 어렵다고한다.



### 혼성 암호 체계와 세션 키

비대칭 공개키 암호 방식은 누구나 공개키만 알면 그 키에 대응되는 공개 서버에 안전하게 메시지를 보낼수 있게 해주므로 훌륭하다.

두 노드가 안전하게 의사소통을 하려고 할 때 개인 키에 대한 협상을 먼저 해야할 필요가 없다.

그러나 공개키 암호 방식의 알고리즘은 계산이 느린 경향이 있다.

실제로 대칭과 비대칭 방식을 섞은 것이 쓰인다.

예를들어, 노드들 사이의 안전한 의사소통 채널을 수립할 때는 편리하게 공개 키 암호를 사용하고, 이렇게 만들어진 안전한 채널을 통해 임시의 무작위 대칭키를 생성하고 교환하여 나머지 데이터를 암호화 할 때는 빠른 대칭키(암호화, 복호화 작업이 빠른)를 사용하는 방식이 흔히 쓰인다.





## 디지털 서명

누가 메시지를 썻는지 알려주고 그 메시지가 위조되지 않았음을 증명하기 위해 메시지에 서명을 하도록 하는데에 이용될수있다.



### 서명은 암호 체크섬이다.

이들은 두가지 이점을 가진다.

- 서명은 메시지를 작성한 저자가 누군지 알려준다.

  저자는 저자의 극비 개인크를 갖고 있기 때문에, 오직 저자만이 이 체크섬을 계산할 수 있다.

  체크섬은 저자의 개인 서명처럼 동작한다.

- 서명은 메시지 위조를 방지한다. 만약 악의적인 공격자가 송신 중인 메시지를 수정했다면, 체크섬은 더 이상 그 메시지와 맞지 않게 될 것이다.

  그리고 츠크섬은 저자의 비밀 개인키에 관련되어 있기 때문에, 침입자는 그 위조된 메시지에 대한 올바른 체크섬을 날조해낼 수 없을 것이다.

![image-20220723152040065](14장 보안HTTP.assets/image-20220723152040065.png) 





## 디지털 인증서

디지털 인증서(cert)는 신뢰할수 있는 기관으로부터 보증 받은 사용자나 회사에 대한 정보를 담고있다.

우리는 많은 형태의 증명을 주고받는다.

여권이나 운전면허같은 ID는 충분한 신뢰를 받는다.

### 인증서의 내부

디지털 인증서에는 또한 공식적으로 '인증기관'에 의해 디지털 서명된 정보의 집합이 담겨있다.

- 대상의 이름 (사라므 서버, 조직 등)
- 유효기간
- 인증서 발급자
- 인증서 발급자의 디지털 서명

추가적으로 인증서는 대상과 사용된 서명 알고리즘에 대한 서술적인 정보뿐아니라 대상의 공개키도 담고있다.



### X.509 v3 인증서

디지털인증서에 대한 전 세계적인 단일 표준은 없다.

모든 인쇄된 ID카드가 같은 위치에 같은 정보를 담고 있지 않는 것처럼, 여러가지 미묘하게 다른 스타일의 디지털 인증서들이 존재한다.

다행인것은 오늘날 사용되는 대부분의 인증서가 그들의 정보를 X.509라 불리는 표준화된 서식에 저장하고 있다는점이다.

X.509 서식에는 다음과 같은 정보가 담겨있다.

![image-20220723152538025](14장 보안HTTP.assets/image-20220723152538025.png) 

![image-20220723152640252](14장 보안HTTP.assets/image-20220723152640252.png) 

 

### 서버 인증을 위해 인증서 사용하기

사용자가 HTTPS를 통한 안전한 웹 트랜잭션을 시작할 때, 최신 브라우저는 자동으로 접속한 서버에서 디지털 인증서를 가져온다.

만약 서버가 인증서를 갖고있지 않다면 보안 커넥션을 실패한다.

서버 인증서는 다음을 포함한 많은 필드를 갖고있다.

- 웹 사이트의 이름과 호스트명
- 웹 사이트의 공개키
- 서명 기관의 이름
- 서명 기관의 서명

브라우저가 인증서를 받으면, 서명 기관을 검사한다.

만약 그 기관이 공공이 신뢰할만한 서명 기관이라면 브라우저는 그것의 공개키를 이미 알고 있을 것이며 

(브라우저는 여러 서명 기관의 인증서가 미리 설치된 채로 출하된다.)

브라우저는 그 서명을 검증할 수 있다.

만약 서명 기관이 모르는 곳이라면, 브라우저는 그 서명 기관을 신뢰해야 할지 확신할 수 없으므로, 

**대개 사용자가 서명 기관을 신회하는지 확인하기 위한 대화상자를 보여준다.**



## HTTPS 세부사항

HTTPS는 HTTP의 가장 유명한 보안버전이다.

널리 구현되어있으며 주류 사용 브라우저와 서버에 구현이 되어있다.

HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것이다.



### HTTPS 개요 

HTTPS는 보안 전송 계층을 총해 전송되는 HTTP이다.

암호화 되지않은 HTTP메시지를 TCP를 총해 전 세계 인터넷으로 보내는 대신 TCP로 보내기전 그것들을 암호화 하는 보안계층으로 보낸다.

오늘날, HTTP의 보안 계층은, SSL과 그것의 현대적 대체품은 TLS로 구현되었다.

우리는 SSL과 TLS를 모두의미하는 단어로 **SSL**을 사용하는 관행을 따를 것이다.



### HTTPS 스키마

오늘날 보안 HTTP는 선택적이다.

클라이언트는 웹 리소스에 대한 트랜젝션 수행요청을 받으면 URL스키마를 검사한다.

- 만약 URL이 http 스키마를 가지고있다면, 클라이언트는 기본 포트`(:80)` 로 연결하고 평범한 HTTP명령을 전송한다.
- 만약 URL이 https 스키마를 가지고있다면, 클라이언트는 서버에 보안 기본포트 `(:443)` 로 연결하고 서버와 바이너리포맷으로된 몇몇 SSL보안 매개변수를 교환하면서 암호화된 HTTP 명령이 뒤를 잇는다.

SSL 트래픽은 바이너리 프로토콜이기 때문에, HTTP와는 완전히 다르다.

그 트래픽은 다른포트(SSL은 보통 443 포트를 통해 전달된다.)로 전달된다.

만약 SSL과 HTTP모두 80포트로 도착한다면, 대부분의 웹 브라우저는 바이너리 SSL트래픽을 잘못된 HTTP로 해석하고 커넥션을 닫을 것이다.



### 보안 전송 셋업

암호화되지 않은 HTTP에서, 클라이언트는 웹 서버의 80번 포트로 TCP 커넥션을 열고, 요청/응답 메시지를 받고 커넥션을 닫는다.

하지만 HTTPS에서는 절차가 보안계층 덕분에 약간더 복잡하다.

클라이언트는 먼저 웹 서버의 443 포트로 연결한다.

일단 TCP 커넥션이 연결되고 나면, 클라이언트와 서버는 암호법 매개변수와 교환키를 협상하면서 SSL계층을 초기화한다.

핸드셰이크가 완료되면 SSL초기화는 완료되며, 클라이언트는 요청메시지를 보안 계층에 보낼 수 있다.

이는 TCP로 보내지기 전에 암호화된다.



### SSL 핸드셰이크

암호화된 HTTP메시지를 보낼 수 있게 되기전에, 클라이언트와 서버는 SSL핸드셰이크를 할 필요가 있다.

- 프로토콜 버전 번호 교환
- 양쪽이 알고 있는 암호선택
- 양쪽의 신원을 인증
- 채널을 암호화하기 위한 임시 세션키 생성

암호화된 HTTP 데이터가 네트워크를 오가기도 전에, SSL은 통신을 시작하기 위해 상당한 양의 핸드셰이크 데이터를 주고 받는다.

![image-20220723154843224](14장 보안HTTP.assets/image-20220723154843224.png) 

SSL이 어떻게 사용되는가에 따라 이는 더 복잡해 질수있지만 일반적인 개념을 보여주고있다.



### 서버 인증서

오늘날 클라이언트 인증서는 웹 브라우징에선 흔히쓰이지 않는다.

대부분의 사용자는 개인 클라이언트 인증서를 갖고 있지도 않다.

웹서버는 클라이언트 인증서를 요구할 수 있지만, 실제로는 좀처럼 일어나지 않는다.

한편 보안 HTTPS 트랜젝션은 항상 서버 인증서를 요구한다.

서버 인증서는 조직의 이름, 주소, 서버 DNS 도메인 이름, 그리고 그 외의 정보를 보여주는 X509 v3에서 파생된 인증서이다.

- ![image-20220723155250065](14장 보안HTTP.assets/image-20220723155250065.png) 



### 사이트 인증서 검사

넷스케이프가 제안한 웹 서버 인증서 검사를 위한 알고리즘은 대부분 웹 브라우저의 검사 기법의 기초를 구축했다.

이 알고리즘의 수행 단계는 다음과 같다.

- 날짜 검사

  인증서의 시작 및 종료일을 검사한다.

- 서명자 신뢰도 검사

  인증 기관에 의해 서명된 인증서를 각각다른 수준의 배경 검증을 요구한다.

  보통 인증서가 알려져 있지 않은 기관이라면 브라우저는 보통 경고를 보여준다.

- 서명 검사

  한번 서명 기관이 믿을 만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용하여 체크섬과 비교해봄으로써 무결성을 검사한다.

- 사이트 신원 검사

  대부분의 브라우저는 인증서의 도메인 이름이 대화중인 서버의 도메인 이름과 비교하여 맞는지 검사한다.

  서버 인증서에는 보통 단일 도메인 이름이 들어있지만 몇몇 CA는 서버 클러스터나 서버팜을위해 와일드 카드 표현이 들어있는 인증서를 만든다.



## 진짜 HTTPS 클라이언트

SSL은 복잡한 바이너리 프로토콜이다.

암호 전문가가 아닌이상, 가공되지 않은 SSL 트래픽을 직접 보내지 않는것이좋다.

다행히도 몇가지 SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어준 상용 혹은 오픈 소스 라이브러리들이 존재한다.



### Open SSL

SSL과 TLS의 가장 인기있는 오픈소스 구현이다.

OpenSSL프로젝트는 강력한 다목적 암호법 라이브러리인 동시에 SSL과 TLS프로토콜을 구현한 강력하고 완전한 기능을 갖춘 자원봉사자들의 결과물이다.

http://www.openssl.org에서 이에대한 정보를 얻을 수 있고, 다운받을수 있다.





## 프록시를 통한 보안 트래픽 터널링

클라이언트는 종종 대신하여 웹 서버에 접근해주는 웹 프록시 서버를 이용한다.

그중 경계 보안 프록시는 방화벽 라우터가 HTTP 트래픽의 교환을 허락한 유일한 장치이며, 

바이러스 검사나 콘텐츠 제어를 수행할 것이다.

만약 회사의 경계 보안 프록시를 설치하고,

클라이언트가 서버로 보낼 데이터를 서버의 공개키로 암호화했다면, 프록시는 더 이상 HTTP헤더를 읽을수 없다.

그리고 이 암호화된 HTTP요청은 갈곳을 잃게 될 것이다.

HTTPS가 프록시와도 잘 동작할수 있게 하기위해, 클라이언트가 프록시에게 어디에 접속하는지 말해주는 방법을 약간 수정해야한다.

인기 있는 기법중 하나는 HTTPS SSL 터널링 프로토콜이다.

클라이언트는 먼저 프록시에게 자신이 연결하고자 하는 안전한 호스트와 포트를 말해준다.

이 내용은 프록시가 읽을 수 있도록 암호화가 시작되기 전의 평문으로 말해준다.

**HTTP는 CONNECT라 불리는 확장 메서드**를 이용해 서버사이에서 데이터가 오갈수 있게 해주는 터널을 만든다.

만약 커넥션을 수립하기 위한 핸드셰이크가 성공했다면, SSL 데이터 전송이 시작된다.

프록시는 요청을 평가하여 그것이 유효하고 사용자가 그러한 커넥션 요청을 허가받았는지 확인한다.

만약 모든것이 적법하다면 `200 Connection Established`응답을 클라이언트에게 보낸다.





### 웹 방화벽 같은 경우는 SSL갱신을 해줘야한다.

웹 프록시 사용안된다.

퍼블릭 캐싱이 안된다.

방화벽은 보안을 위해 요청의 정보 안의 내용을 봐야하는데 SSL이 되어있으면 볼수있없으니까 방화벽 쪽도 SSL을 갱신해주어야한다.





### SSL과 TLS

RFC 2246, "TLS Protocol Version 1.0" 은 SSL을 계승하였다.

TLS는 인터넷상에서의 통신을 남이 엿보거나 방해할 수 없도록 보호해준다.

SSL은 넷스케이프에 의해 처음 개발된 WWW인증과 클라이언트 서버 사이의 암호화된 통신을 위해 전 세계적으로 받아들여졌다.