## HTTP 2.0

HTTP/1.1의 메시지 포멧은 구현의 단순성과 접근성에 주안점을 두고 최적화되었다.

그러다 보니 성능은 어느정도 희생시키지 않을수 없었다.

커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 HTTP의 메시지 교환 방식은 단순함 면에서는 좋지만, 심각한 회전지연을 피해갈수 없다.

마침내 HTTP/2.0은 Google의 SPDY 프로토콜의 특징을 거의 유지한채 우리에게 선보여졌다.



### 개요

HTTP/2.0은 서버와 클라이언트 사이의 TCP 커넥션 위에서 동작한다.

이때 TCP 커넥션을 초기화하는 것은 클라이언트다.

HTTP/2.0의 요청과 응답은 정의된 한개 이상의 프레임에 담긴다. (최대 16383 Byte)

**이때 HTTP 헤더는 압축되어 담긴다.**

프레임들에 담긴 요청과 응답은 스트림을 통해 보내진다.

한개의 스트림이 한 쌍의 요청과 응답을 처리한다.

하나의 커넥션 위에 여러 개의 스트림이 동시에 만들어질 수 있으므로, 여러개의 요청과 응답을 동시에 처리하는 것 역시 가능하다.

HTTP/2.0은 기존 요청-응답과는 약간 다른 새로운 상호작용 모델인 **서버푸시**를 도입했다.

이를 통해 클라이언트가 필요하다고 생각하는 리소스를 요청을 명시적으로 받지 않더라도 능동적으로 클라이언트에 보내줄수있다.



또한 기존 웹 애플리케이션과의 호환성을 최대한 유지하기 위해 **이를 표현하는 문법은 변경이 되었지만 요청과 응답 메시지의 의미를 HTTP/1.1과 같도록 유지**하고있다.



### HTTP/1.1 과의 차이점

#### 프레임

HTTP/2.0 에서 모든 메시지는 프레임에 담겨 전송된다.

모든 프레임은 8바이트 크기의 헤더로 시작하며, 뒤이어 최대 16383바이트 크기의 페이로드가 온다.

![image-20220720200333130](10장 HTTP2.0.assets/image-20220720200333130.png) 

필드는 다음과 같다.

- R : 예약된 2비트 필드, 값의 의미가 정의되어 있지 않으며, 반드시 `( )` 이어야한다.

  받는쪽에서는 이 값을 무시해야한다.

- 길이 : 페이로드의 길이를 나타내는 14비트 무부호 정수이다.
- 종류 : 프레임의 종류
- 플래그 : 8비트의 플래그이며 플래그 값의 의미는 프레임의 종류에 따라 다르다.
- R : 예약된 1비트 필드, 첫번째 R과 마찬가지로 값의 의미가 정의되어있지 않으며 반드시 `( )`이어야한다.
  받는쪽에서는 이 값을 무시해야한다.
- 스트림 식별자  : 31비트 식별자, 특별히 `()`은커넥션 전체와 연관된 프레임을 의미한다.



#### 스트림과 멀티플렉싱

스트림은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에서 교환되는 프레임들의 독립된 양방향 서비스이다.

한 쌍의 HTTP 요청과 응답은 하나의 스트림을 통해 이루어진다.

클라이언트는 새 스트림을 만들어 그를 통해 HTTP요청을 보낸다.

HTTP/1.1 에서는 TCP커넥션을 만들어 요청후 응답을 기다리고 나서 같은 TCP로 통신을 하게된다.

하지만 TCP 커넥션을 무한정 만들수 있는것도 아니라서 한페이지에 보내야 할 요청이 수십에서 수백에 달하는 오늘날에는 회전 지연이 늘거나는 것을 피하기 어렵다.

그러나 HTTP/2.0 에서는 하나의 커넥션에 여러개의 스트림이 동시에 열릴수있다.

뿐만 아니라 스트림은 우선순위도 가질수 있어 프레임 전송이 느리다면 보다 중요한 리소스의 요청에 우선순위를 부여할수 있다.

HTTP/2.0 에서 커넥션을 한번 사용한 스트림 식별자는 다시 사용할수 없다.

커넥션을 오래 사용하다보면 스트림에 할당할 수 있는 식별자가 고갈되기도 하는데, 그런 경우에는 커넥션을 다시 맺으면된다.



#### 헤더압축

HTTP/1.1 에서 헤더는 아무런 압축 없이 그대로 전송되었다.

요즘에는 웹페이지 하나를 보기위해 많은 요청을 보내기 때문에, 헤더의 크키가 회전 지연과 대역폭 양쪽 모두에 실질적인 영향을 끼치게된다.

이를 개선하기위해 HTTP/2.0 에서는 헤더를 압축하여 보낸다.

헤더는 HPACK 명세에 정의된 헤더 압축 방식으로 압축되며 헤더 블록 조각들로 쪼개져서 전송된다.

받는 쪽은 이 조각의 압축을 풀어 원래의 헤더 집합으로 복원한다.

헤더를 받는쪽은 콘텍스트 변경의 오작동을 막기위해 커넥션을 사용하지 않더라도 반그시 압축 해제를 수행해 주어야한다.

만약 그럴수 없다면 반드시 COMPRESSION_ERROR와 함께 커넥션을 끊어야한다.



#### 서버 푸시

HTTP/2.0은 서버가 하나의 요청에 대해 응답으로 여러개의 리소스를 보낼수 있도록 해준다.

보내기전 리소스를 푸시하려는 서버는 먼저 클라이언트에게 자원을 푸시 할 것임을 PUSH_PROMISE 프레임을 보내어 미리 알려주어야한다.

이 상태에서 클라이언트는 '예약됨' 상태가 되며 RST_STREAM을 보내어 이를 거절할 수 있다.

서버푸시를 사용할때는 다음을 주의해야한다.

- 서버 푸시를 사용하기로 했더라도, 중간의 프록시 서버로부터 받은 추가 리소스를 클라이언트에게 전달하지 않을 수 있으며, 
  반대로 추가 리소스를 받지않아도 클라이언트에게 추가 리소스를 전달할수 있다.
- 서버는 오직 안전하고, 캐시 가능하고, 본문을 포함하지 않는 요청에 대해서만 푸시할수있다.
- 푸시할 리소스는 클라이언트가 명시적으로 보낸 요청과 연관된 것이어야한다.
- 클라이언트는 반드시 서버가 푸시한 리소스를 동일 출처 정책 (Same-origin policy)  에 따라 검사해야한다.
- 마지막으로, 서버 푸시를 끄고 싶다면 SETTING)ENABLE_PUSH을 0으로 설정하면된다.





### 알려진 보안이슈

- 중재자 캡슐화 공격

  HTTP/2.0 메시지를 중간의 프록시가 HTTP/1.1 메시지로 변환할때 메시지의 의미가 변질된 가능성이있다.

  HTTP/2.0은 헤더 필드의 이름과 값을 바이너리로 인코딩한다.

  HTTP/1.1로 변환하는 과정에서 줄바꿈 문자열등에 의해 변질될 가능성이 있다.

  하지만 다행이 HTTP/1.1을 HTTP/2.0으로 변환하는 과정에서는 이런 문제가 발생하지 않는다.

- 긴 커넥션으로 인한 개인정보 누출 우려

  HTTP/2.0 사용자가 요청을 보낼 때의 회전 지연을 줄이기 위해 클라이언트와 서버 사이의 커넥션을 오래 유지하는 것을 염두에 두고있다.

  이것은 개인 정보의 유출에 악용이 될 가능성이 있다.

  이것은 HTTP 현재 갖고 있는 문제이기도 하지만 상대적으로 짧은 커넥션을 유지하기에 위험이 적다.



