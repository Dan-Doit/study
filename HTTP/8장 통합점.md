## 통합점

시간이 지나면서 사람들은 온라인에 단순히 정적인 문서뿐만 아니라 더욱 복잡한 리소스를 공유하기원했다.

브라우저 같은 HTTP 애플리케이션은 인터넷상의 콘텐츠에 접근하는 통일된 방법을 제공한다.





## 게이트웨이

### 게이트웨이

HTTP의 확장과 인터페이스는 사람들의 필요에 따라 발전해왔다.

웹에 더 복잡한 리소스를 올려야 할 필요가 생기면서, 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없다는 것은 분명해졌다.

개발자들은 이 문제에 대한 해결책으로, 인터프리터같이 리소스를 받기위한 경로를 안내하는 역할을 하는 데이트웨이를 고안해냈다.

게이트웨이는 리소스와 애플리케이션을 연결하는 역할을 한다.

게이트웨이는 요청을 받고 응답을 보내는 포탈같이 동작하는데, 동적인 컨턴츠를 생성하거나 데이터 베이스에 질의를 보낼수있다.

- 클라이언트 측 게이트웨이와 서버 측 게이트웨이

  웹 게이트웨이는 한쪽에서는 HTTP로 통신하고 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신한다.

  서버 측 게이트웨이는 클라이언트와 HTTP로 통신하고, 서버와는 외래 프로토콜로 통신한다.

  클라이언트 측 게이트웨이는 클라이언트와 외래 프로토콜로 통신하고, 서버와는 HTTP로 통신한다.



### 프로토콜 게이트웨이

프록시 트래픽을 바로 보내는 것과 같이 게이트웨이에도 HTTP트래픽을 바로 보낼 수 있다.

보통 브라우저에 명시적으로 게이트웨이를 설정하여 자연스럽게 트래픽이 게이트웨이를 거쳐가게 하거나, 게이트웨이를 리버스 프록시로 설정할수도있다.

- HTTP/* : 서버 측 웹 게이트웨이

  서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP요청을 외래 프로토콜로 전환한다.

- HTTP/HTTPS: 서버측 보안 게이트웨이

  기업 내부의 모든 웹 요청을 암호화함으로써 개인 정보 보호와 보안을 제공하는데 게이트웨이를 사용할 수 있다.

  일반 HTTP를 사용하여 웹을 탐색하지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화한다.

- HTTPS/HTTP: 클라이언트 측 보안 가속 게이트웨이

  이 게이트웨이는 웹 서버의 앞단에 위치하고, 보이지 않는 인터셉트 게이트웨이나 리버스 프록시역할을한다.

  HTTPS 트래픽을 받아 복호화하고, 웹서버로 보낼 일반 HTTP요청을 만든다.



### 리소스 게이트웨이

게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이를 한개의 서버로 결합한다.

애플리케이션 게이트웨이에서 유명했던 공용 게이트웨이 인터페이스(CGI) 는 HTTP요청에 따라 프로그램을 실행하고,

프로그램을 출력을 수집하고, HTTP 응답으로 회신하는데 서버가 사용하는 표준화된 인터페이스의 집합이다.





## 터널

HTTP의 또다른 방식중 하나인 웹 터널은 HTTP프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공한다.

웹 터널을 사용하면 HTTP 커넥션을 통해서 HTTP가 아닌 트래픽을 전송할 수 있고, 다른 프로토콜을 HTTP 위에 올릴수 있다.

웹 터널을 사용하는 가장 일반적인 이유는 HTTP 커넥션 안에 HTTP가 아닌 트래픽을 얹기 위해서다.

따라서 웹 터널을 사용하면 웹 트래픽만을 허락하는 방화벽이 있더라도 HTTP가 아닌 트래픽을 전송할수 있다.

- CONNECT로 HTTP 터널 커넥션 맺기

  웹 터널은 HTTP의 CONNECT 메서드를 사용하여 커넥션을 맺는다.

  CONNECT 매서드는 HTTP/1.1 명세에는 자세히 나와있지는 않지만, 많이 구현하는 확장이다.

  CONNECT 매서드는 터널 데이트웨이가 임의의 목적 서버와 포트에 TCP 커넥션을 맺고 클라이언트와 서버간에 오는 데이터를 무조건 전달하기를 요청한다.

  - CONNECT 요청

    문법은 시작줄을 제외하고는 다른 HTTP 메서드와 같다.

    요청 URI는 호스트명을 대신하며 콜론에 이어 포트를 적어준다.

    ```http
    CONNECT home.netscape.com:443 HTTP/1.0
    User-agent: Mozilla/4.0
    ```

  - CONNECT 응답

    요청이 전송되고 나면, 게이트웨이의 응답을 기다린다.

    일반 HTTP 메시지와 같이 200 응답 코드는 성공을 뜻한다.

    보통 OK 메시지 대신 'Connection Established'로 적는다.

    ```http
    HTTP/1.0 200 Connection Established
    Proxy-agent: Netscape-Proxy/1.1
    ```

- 데이터 터널링, 시간, 커넥션

  터널을 통해 전당되는 데이터는 게이트웨이에서 볼수 없어서, 게이트웨이는 패킷의 순서나 흐름에 대란 어떤 가정도 할 수 없다.

  터널이 일단 연결되면, 데이터는 언제 어디로든 흘러가버릴 수 있다.

  클라이언트는 성능을 높이기 위해 CONNECT 요청을 보낸다음, 응답을 받기전에 터널 데이터를 전송할 수있다.

  이는 서버에 데이터를 더 빨리 보내는 방법이지만, 게이트웨이가 요청에 이어서 데이터를 적절하게 처리할수 있어야 함을 전제로한다.

- SSL 터널링

  웹 터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하기위해 개발되었다.

  많은 회사가 더 강력한 보안을 위해 모든 트래픽이 패킷을 필터링하는 라우터와 프록시를 지나도록 하였다.

  하지만 SSL 같이 암호화된 프로토콜은 정보가 암호화되어 있기 때문에 낡은 방식의 프록시는 이를 처리하지 못한다.

  터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 90포트의 HTTP만을 허용하는 방화벽을 통과시킬 수 있다.

  ![image-20220717153051547](8장 통합점.assets/image-20220717153051547.png) 

- SSL 터널링 vs HTTP/HTTPS 게이트웨이

  HTTPS 프로토콜은 다른 프로토콜과 같은 방식으로 게이트웨이를 통과할수 있다.

  원격 HTTPS서버와 SSL 세션을 시작하는 게이트웨이를 두고 클라이언트 측의 HTTPS 트랜잭션을 수행하는 방식이다.

  응답은 프록시가 받아서 복호화하고 난 후에, HTTP를 통해 클라이언트로 전송한다.

  하지만 이는 클라이언트와 게이트웨이사이에 보안이 적용되어있지 않은 HTTP통신을 하는것과 

  프록시 쪽에서 인증을 담당하기때문에, 클라이언트는 원격 서버에 SSL 클라이언트 인증을 할수 없다.

  이 상황에 SSL 터널링 사용하면, 프록시에 SSL을 구현할 필요가 없다.

  SSL세션은 클라이언트가 생성한 요청과 목적지 웹 서버간에 생성된다.

  그리고 이는 트랜잭션의 보안에는 관여하지 않고 암호화된 데이터를 그대로 터널링 할 뿐이다.



## 릴레이

HTTP릴레이는 HTTP 명시를 완전히 준수하지 않는 간단한 HTTP프록시이다.

릴레이는 커넥션을 맺기 위한 HTTP 통신을 한 다음, 바이트를 맹목적으로 전달한다.

HTTP는 복잡하기에, 모든 헤더와 메서드 로직을 수행하지 않고 맹목적으로 트래픽을 전달하는 간단한 프록시를 구현하는 방식이 유용할때가 있다.

단순 맹목적인 릴레이를 구현하는데 관련된 가장 큰 문제중 하나는 맹목적 릴레이가 Connection 레더를 데재로 처리하지 못해서 keep-alive 커넥션이 행에 걸리는것이다.

이러한 위험을 예방하기 위해 릴레이를 조금이나마 똑똑하게 만드는 방법이 있지만, 프록시의 단순함 이면에는 상호 운용과 관련된 문제가 발생할 위험이 있다.

