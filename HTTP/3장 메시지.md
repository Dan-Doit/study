## HTTP 메시지

HTTP가 **인터넷의 배달원**이라면, **HTTP 메시지는 무언가를 담아보내는 소포**와같다.

---



## 메시지의 흐름

HTTP 메시지는 HTTP 애플리케이션 간에 주고받는 데이터의 블록들이다.

이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다.

이 메시지는 **클라이언트, 서버, 프록시** 사이를 흐른다.

인바운드, 아웃바운드, 다운스트림은 메시지의 방향을 의미하는 용어이다.



>프록시(Proxy)란?
>
>'대리'라는 의미로,네트워크 기술에서는 프로토콜에 있어서 대리 응답 등에서 친숙한 개념입니다. 
>보안 분야에서는 주로 보안상의 이유로 직접 통신할 수 없는 두 점 사이에서 통신을 할 경우 그 상이에 있어서 **중계기**로서 대리로 통신을 수행하는 기능을 가리켜 '프록시', 그 중계 기능을 하는 것을 프록시 서버라고 부릅니다.
>
>특징
>
>프록시 서버는 단순히 보안상의 이유만으로 설치하는 것은 아닙니다. 
>물론 보안상의 목적으로 설치하는 경우가 많겠지만, 그렇다고 그렇게 단순하게 볼 수만은 없을 것입니다. 
>우선 프록시 서버는 프록시 서버에 요청된 내용들을 캐시를 이용하여 저장해 둡니다. 
>이렇게 캐시를 해 두고 난 후에, **캐시 안에 있는 정보를 요구하는 요청에 대해서는 원격 서버에 접속하여 데이터를 가져올 필요가 없게 됨으로써 전송 시간을 절약**할 수 있게 됨과 동시에 **불필요하게 외부와의 연결을 하지 않아도 된다**는 장점을 갖게 됩니다. 
>또한 **외부와의 트래픽을 줄이게 됨으로써 네트워크 병목 현상을 방지하는 효과**도 얻을 수 있게 됩니다.

>Forward 프록시
>
>이것은 프록시 서버를 '클라이언트 호스트들과 접근하고자 하는 원격 리소스의 사이'에 위치시키는 것입니다.
>이 프록시 서버는 원격 서버로부터 요청된 리소스를 가져와서 요청한 사용자에게 돌려주는 역할을 수행하며, 만일 캐시에 데이터가 남아 있다면 다음 요청시 캐시된 데이터로부터 제공해 주게 됩니다. 
>이 서버는 전형적으로 로컬 디스크에 데이터를 저장하며, 클라이언트 호스트들은 사용중인 웹 브라우저를 이용하여 프록시 서버 사용 설정을 해야 하므로 프록시 서버를 사용하고 있다는 것을 인식할 수 있을 것입니다. 
>**이 방식은 대역폭 사용을 감소시킬 수 있다는 것**과 접근 정책 구현에 있어 다루기 쉬우면서도 비용이 저렴하다는 장점을 갖습니다. 
>또한 사용자의 정해진 사이트만 연결할수 있는 등 웹 사용 환경을 제한할 수 있으므로 기업 환경등에서 많이 사용합니다. 

>Reverse 프록시
>
>이것은 프록시 서버를 '인터넷 리소스 또는 인트라넷 리소스 앞'에 위치시키는 방식입니다. 
>이 방식을 사용하면 클라이언트들이 프록시 서버에 연결되었다는 것을 알지 못하게 되며, 마치 최종 사용자가 요청 리소스에 직접 접근하는 것과 같이 느끼게 됩니다. 
>내부 서버가 직접 서비스를 제공해도 되지만 이렇게 구성하는 이유는 보안 때문입니다. 
>보통 기업의 네트워크 환경은 DMZ 라고 하는 내부 네트워크와 외부 네트워크 사이에 위치하는 구간이 존재하며 이 구간에는 메일 서버, 웹 서버, FTP 서버등 외부 서비스를 제공하는 서버가 위치하게 됩니다. 
>[example.com](http://example.com/) 사는 서비스를 자바로 구현해서 WAS 를 DMZ 에 놓고 서비스해도 되지만 WAS 는 보통 DB 서버와 연결되므로 WAS 가 최전방에 있으면 WAS 가 털릴 경우 DB 서버까지 같이 털리는 심각한 문제가 발생할 수 있습니다. 
>이 때문에 리버스 프록시 서버를 두고 실제 서비스 서버는 내부망에 위치시키고 프록시 서버만 내부에 있는 서비스 서버와 통신해서 결과를 클라이언트에게 제공하는 방식으로 서비스를 하게 됩니다.
>특히 리눅스 환경에서 리버스 프록시로 아파치 웹 서버를 사용한다면 SELinux 를 켜 놓으면 SELinux 의 기본 정책이 웹 서버는 톰캣의 8080, 8009 포트만 접근 할 수 있으므로 아파치 웹 서버가 해킹당해도 웹 서버 권한으로는 내부망으로 연결이 불가합니다. 
>또한 리버스 프록시 방식은 각 요청에 대한 데이터가 캐시되기 때문에 프록시 서버는 실제 서버들을 위한 부하조절 기능을 가질 수 있습니다. 
>
>[출처: 불곰의 블로그](https://brownbears.tistory.com/191)



- 메시지는 원 서버 방향을 인바운드로 하여 송신된다.

  HTTP는 인바운드와 아웃바운드라는 용어를 트랜잭션 방향을 표현하기 위해 사용한다.

  메시지가 원 서버로 향하는 것은 **인바운드**이고, 처리가 끝난 후 사용자 클라이언트로 돌아가는것을 **아웃바운드**라고한다.

- 다운스트림으로 흐르는 메시지

  HTTP 메시지는 강물처럼 흐른다. 요청이냐 응답이냐 관계없이 모든 메시지는 다운스트림(물결처럼)으로 흐른다.

  메시지의 발송자는 수신자의 업 스트림이다. 반대로 응답에서는 발송자가 다운 스트림이다.

  >'업스트림', '다운스트림' 이란 용어는 방송자와 수신자의 대한것이다.
  >
  >메시지가 원 서버를 향하는가 아니면 클라이언트를 향하는가에 대한것이 아니다.
  >
  >어느 방향이든 다운스트림이기 때문이다.

![image-20220710141926328](3장 메시지.assets/image-20220710141926328.png) 





## 메시지의 부분

HTTP 메시지는 단순하느 데이터의 구조화된 블록이다.

각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답중 하나를 포함한다.

다음 3자의 역할로 나뉘게 된다.

- 시작줄 : 어떤 메시지 인지 서술하는 부분 *(줄 단위로 분리된 아스키 문자열)*
- 헤더 블록 : 속성을 나타내는 부분 *(줄 단위로 분리된 아스키 문자열)*
- 본문 : 데이터를 담고 있는 부분 *(아무것도 없이 보낼수 있다.)*

![image-20220710141909908](3장 메시지.assets/image-20220710141909908.png) 



### 메시지 문법

모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다.

요청(Request)은 서버로부터 어떤 동작을 요구하며, 응답(Response)은 요청의 결과를 돌려준다.

요청 메시지의 형태는 다음과 같다.

```http
<메서드> <요청 URL> <버전>
<헤더>
<본문>
```

응답 메시지의 형식은 다음과 같다.

```http
<버전> <상태 코드> <사유 구절>
<헤더>
<본문>
```

- 메서드 : 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작이다. (`GET`,`POST` 와같은 한개의 단어로 되어있다.)
- 요청 URL : 대상이 되는 리소스를 지칭하는 완전한 URL 또는 경로 구성요소 이다.
- 버전 : 이 메시지가 사용중인 HTTP의 버전이다. ( `HTTP/<메이저>.<마이너>` 로 이루어져 있다.)

- 상태 코드 : 요청중에 무슨일이 일어났는지 설명하는 세자리 숫자이다. (`성공`,`에러`의 대한 부분도 정의한다.)
- 사유 구절 : 숫자로 된 상태 코드의 의미를 사람이 이해하도록 설명해주는 짧은 문구이다.
- 헤더 : 이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 줄들이다.
- 본문 : 임의의 데이터 블록을 포함한다. 때로는 그냥 CRLF로 끝나게 될때도 있다 *(아무값도 없을경우)*.



### 시작줄

모든 HTTP 메시지는 시작줄로 시작한다.

요청 메시지의 시작줄은 무엇을 해야하는지 말해준다.

응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.

- 요청줄

  서버에 무언가 해달라고 부탁한다. 메시지의 시작줄은 어떤 동작이 일어나야 하는지 설명해주는 메서드와

  그 동작에 대한 대상을 지칭하는 요청 URL이 들어있다. 물론 버전도 여기에 포함된다.

- 응답줄

  수행 결과에 대한 상태정보와 결과 데이터를 클라이언트에게 돌려준다.

  버전, 상태코드, 상태에 대해 설명해주는 텍스트 사유구절이 들어있다.

  이 모든 필드는 공백으로 구분된다.

- 메서드

  서버에게 무엇을 해야하는지 말해준다.

  메서드에 따라 요청 메시지에 본문이 있는경우도 있도 그렇지 않은 경우도 있다.

  다음은 메서드가 정리된 표이다.

  | 메서드  | 설명                                                    |
  | ------- | ------------------------------------------------------- |
  | GET     | 서버에서 어떤 문서를 가져온다.                          |
  | HEAD    | 서버에서 어떤 문서에 대해 헤더만 가져온다.              |
  | POST    | 서버가 처리해야 할 데이터를 보낸다.                     |
  | PUT     | 서버의 요청 메시지의 본문을 저장한다.                   |
  | TRACE   | 메시지가 프록시를 거쳐 서버에 도달하는 과정을 추적한다. |
  | OPTIONS | 서버가 어떤 메서드를 수행할 수 있는지 확인한다.         |
  | DELETE  | 서버에서 문서를 제거한다.                               |

  **주의 할점은 모든 서버가 메서드를 모두 구현한 것은 아니라는 점이다.**

  나아가 HTTP는 쉽게 확장할 수 있도록 설계되었기에 서버마다 그들만의 메서를 추가로 구현했을 수도있다.

  이를 확장 메서드라고 부른다.

- 상태 코드

  메서드가 무엇을 해야 하는지 말해주는것 처럼, 상태 코드는 클라이언트에세 무억이 일어났는지 말해준다.

  다음은 상태코드가 정리된 표이다.

  | 전체 범위 | 정의된 범위 | 분류            |
  | --------- | ----------- | --------------- |
  | 100~199   | 100 - 101   | 정보            |
  | 200~299   | 200 - 206   | 성공            |
  | 300~399   | 300 - 305   | 리다이렉션      |
  | 400~499   | 400 - 415   | 클라이언트 에러 |
  | 500~599   | 500 - 505   | 서버 에러       |

  막약 인식할 수 없는 상태 코드를 받게 되면 서버쪽에서 누군가가 현재 프로토콜의 확장으로 정의했을 가능성이 있다.

- 사유 구절

  시작줄의 마지막 구성 요소이다.

  이것은 상태 코드에 대한 글로된 설명을 제공한다.

  예를 들어 `HTTP/1.0 200 OK` 에서 사유 구절은 OK 이다.

  HTTP 명세는 사유 구절이 어때야 한다는 어떤 엄격한 규칙도 제공하지 않는다.

- 버전 정보

  버전의 번호는 요청, 응답 모두에 기술되며 `HTTP/x.y` 형식으로 작성된다.

  이것은 HTTP 애플리케이션들이 자신이 따르는 프로토콜의 버전을 상대방에게 말해주기 위한 수단이 된다.

  버전 번호는 형식에 대한 단서를 제공해준다.

  **HTTP 버전 1.1 애플리케이션과 대화하는 HTTP 1.2 애플리케이션은 1.2 버전의 새로운 기능을 사용할 수 없다.**

  응답의 프로토콜 버전이 `HTTP/1.1` 이라는 것은 사실 응답을 보낸 애플리케이션이 HTTP/1.1 까지 이해할 수 있음을 의미하는 것이다.

- 헤더

  시작줄 다음의 0이상의 여러개의 HTTP 메시지 필드이다.

  이는 요청과 응갑 메시지의 추가 정보를 더한다.

  보통 `이름/값` 쌍의 목록이다.

  다음과 같이 추가 분류를 할수 있다.

  - 일반 헤더 : 요청과 응답 양쪽에 모두 나타날 수 있다.
  - 요청 헤더 : 요청에 대한 부가 정보를 제공한다.
  - 응답 헤더 : 응답에 대한 부가 정보를 제공한다.
  - Entity 헤더 : 본문 크기와 콘텐츠 혹은 리소스 그 자체를 서술한다.
  - 확장 헤더 : 명세에 정의되지 않은 새로운 헤더이다.

  흔희 쓰이는 헤더의 예이다.

  | 헤더의 예시                              | 설명                                            |
  | ---------------------------------------- | ----------------------------------------------- |
  | Date: Tue, 3 Oct 1997 02:16:03 GMT       | 서버가 응답을 만들어 낸 시각                    |
  | Content-length: 15040                    | 15,040 바이트의 데이터를 포함한 엔티티 본문     |
  | Content-Type: image/gif                  | 본문은 GIF 이미지다.                            |
  | Accept: image/gif, image/jpeg, text/html | 클라이언트는 GIF, JPEG, HTML을 받아들일수 있다. |

- 본문

  HTTP 세번째 부분은 선택적인 엔티티 본문이다.

  이 부분은 HTTP 메시지의 화물이라고 할 수 있다.

  이곳은 HTTP가 수송하도록 설계되었다.

  HTTP 메시지는 이미지, 비디오, HTML 문서, 애플리케이션, 신용카드 트렌젝션, 전자우편등 여러 종류의 디지털 데이터를 실어 나를수 있다.



### 버전 0.9 메시지

HTTP 프로토콜의 초기 버전이다.

오늘날 HTTP가 갖고 있는 요청과 응답 메시지의 시초지만, 훨씬 단순한 프로토콜로 되어있다.

0.9 버전에서 요청은 그저 메서드와 요청 URL을 갖고있고, 응답은 오직 엔티티로만 되어있다.

버전의 정보도 없고, 상태 코드나 사유 구절도 없으며, 헤더도 없다.



## 메서드

기본적인 HTTP 메서드에 대해 이야기 해보자



### 안전한 메서드

HTTP는 안전한 메서드라고 불리는 메서드의 집합을 정의한다.

GET과 HEAD 메서그는 안전하다고 할 수 있는데, 이는 GET 이나 HEAD 메서드를 사용하는 HTTP요청의 결과로 서버에서 어떠한 변화도 일어나지 않는다.

하지만 이는 서버 개발자의 의해 안전할지 불 안전할지 결정되는 사항이긴하다.



### GET

GET은 가장 흔히 쓰는 메서드이다.

주로 서버에게 리소스를 달라고 요청하기 위해 쓰인다.

`HTTP/1.1` 은 서버가 이 메서드를 구현할 것을 요구한다.



### HEAD

정확히 GET요청 처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다.

엔티티 본문은 절대 반환되지 않는다.

이는 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다.



### PUT

GET 메서드가 서버로부터 문서를 읽어들이는데 반해 PUT은 문서를 작성한다.

PUT의 의미는 서버가 요청의 본문을 가지고 효청 URL의 이름대로 새 문서를 만들거나, 교체하는데에 있다.

이는 콘텐츠를 변경할수 있기 때문에, 많은 웹 서버가 PUT을 수행하기전 로그인을 하도록 요구한다.



### POST

POST는  서버에 입력 데이터를 전송하기 위해 설계되었다.

실제로, HTML 폼을 지원하기 위해 흔히 사용된다.

채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아 필요한곳에 보낸다.



### TRACE

클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프록시, 게이트웨이 등의 애플리케이션을 통과할수 있다.

TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달될때 어떻게 보이게 되는지 알려준다.

이는 루프백(Loopback) 진단을 통해 이루어지며, 요청 전송의 마지막 단계에 있는 거버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 돌려준다.

따라서 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신의 보낸 메시지가 망가졌거나 수정되었는지, 변경되었는지 확인 할 수있다.

보통 진단을 위해 사용되며 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고하 할 때도 좋은구조이다.

하지만 이는 중간 어플리케이션이 어떻게 이 요청을 처리할 것인지에 따라 다르다.



### OPTIONS

지원 범위에 대해 물어본다.

서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다.

이는 여러 리소스에 대해 실제로 접근하지 않고도 그것을 어떨게 접근하는 것이 최선인지 확인할 수 있는 수단을 클라이언트 애플리케이션에게 제공한다.



### DELETE

삭제할 것을 요청하는 메서드이다.

그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다.

이유는 HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는것을 허용하기 때문이다.

따라서 이는 응답을 하는 서버의 상황을 파악하며 클라이언트 애플리케이션의 응답반응을 조절해야한다.



### 확장 매서드

HTTP는 필요에 따라 확장해도 문제가 없도록 설계되어 있으므로, 새로 기능을 추가해도 과거에 구현된 소프트웨어들의 오동작을 유발하지 않는다.

확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드들이다.

그들은 개발자들에게 그들의 서버가 구현한 HTTP 서비스의 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공한다.

확장 매서드를 다룰때는 "엄격하게 보내고 관대하게 받아들여라" 라는 오랜규칙을 따르는것이 가장좋다.





## 상태코드

HTTP 상태코드는 크게 5가지로 나뉜다.

상태 코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

>트랜잭션(*transaction*)이란
>
>"쪼갤 수 없는 업무 처리의 최소 단위"를 말한다.



### 100-199: 정보성 상태 코드 (page: 67)

HTTP/1.1 에서 도입되었다.

이들은 정의된 정보성 상태 코드를 나열하고 있다.

| 상태 코드 | 사유 구절           | 의미                                                         |
| --------- | ------------------- | ------------------------------------------------------------ |
| 100       | Continue            | 요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미한다.  이것을 보낸 후, 서버는 반드시 요청을 받아 응답해야한다. |
| 101       | Switching Protocols | 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다. |



### 200-299:  성공 상태 코드

이들은 요청이 성공이 되었다는 상태 코드를 나열하고 있다.

| 상태 코드 | 사유 구절                     | 의미                                                         |
| --------- | ----------------------------- | ------------------------------------------------------------ |
| 200       | OK                            | 요청은 정상이고, 본문은 요청된 리소스를 포함하고 있다.       |
| 201       | Created                       | 서버 개체를 생성 하라는 요청에 대한 응답. 반드시 객체가 생성되어야 한다. |
| 202       | Accepted                      | 요청은 받아들여졌으나 아직 그에 대한 어떤 동작도 수행하지 않았다. 또한 완료할 거라는 보장도 하지 않는다. 되도록이면 응답에는 언제 완료될거라는 추정을 포함시키는 것이 좋다. |
| 203       | Non-Authoritative Information | 엔티티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스 사본에서 왔다. 중개자가 리소스의 사본을 갖고 있었지만 리소스에 대한 메터 정보를 검증하지 못한 경우 발생한다. |
| 204       | No Content                    | 응답 메시지는 헤더와 상태줄을 포함하지만 엔티티 본문은 포함하지 않는다. 주로 브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때 사용된다. |
| 205       | Reset Content                 | 주로 브라우저를 위해 사용되는 또 하나의 코드. 현재 페이지의 있는 HTML폼의 모든 값을 비우라고 할때 사용된다. |
| 206       | Partial Content               | 부분 혹은 범위 요청이 성공했다. 나중에 우리는 클라이언트가 특별한 헤더를 사용하여 문서의 부분 혹은 특정 봄위를 요청하게 할수 있다는 것을 보게 될 것이다. 206요청은 반드시 헤더의 Content-Rage와 Date를 포함해야 하며, Etag, Content-Locaiton중 하나의 헤더도 포함해야한다. |



### 300-399: 리다이렉션 상태 코드 (Page: 73)

이는 클라리언트가 관심ㅇ있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 가른 대안 응답을 제공한다.

이 다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을때 유효한지 확인하기 위해 사용된다.

| 상태 코드 | 사유 구절          | 의미                                                         |
| --------- | ------------------ | ------------------------------------------------------------ |
| 300       | Multiple Choices   | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 소스의 목록과 함께 반환된다. 어떤 서버가 하나의 HTML문서를 영어와 프랑스어 모두 제공하는 경우등에 사용할수 있다. |
| 301       | Moved Permanently  | 요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야한다. |
| 302       | Found              | 301 상태 코드와 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용한다. 이후 요청에서는 원래 URL을 사용해야한다. |
| 303       | See Other          | 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할때 쓰인다. 새 URL은 응답 메시지의 Location 레더에 들어있다. 이 상태 코드의 주 목적은 POST 요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려주는 것이다. |
| 304       | Not Modified       | 클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다. 만이 상태 코드를 동반한 응답은 엔티티본문을 가져서는 안된다. |
| 305       | Use Proxy          | 리소스가 반드시 프록시를 통해서 접근되어야 함을 나타내기 위한 코드이다. 클리이언트는 이 응답을 특정 리소스에 대한 것이라고만 해석한다. 클라이언트는 모든 요청에대해 프록시를 통해야 한다고 상정하지 않으며, 이정음 매우 정요하다. 프록시에 잘목 간섭하면 이는 동작 오류를 유발할수 있고, 보안문제도 일으킨다. |
| 306       | (사용 X)           | 현재는 사용되지 않는다.                                      |
| 307       | Temporary Redirect | 301 상태 코드와 비슷하다. 그러나 클라이언트는 Location 레더로 주어진 URL 리소스를 임시로 가리키기 위한 목적으로 사용해야한다. 이후 요청에서는 원해 URL을 사용해야한다. |

302 , 303 , 307 상태 코드 사이에서는 중복되는 부분이 있다.

이 상태 코드들이 어떻게 사용되는가에 대해서는 약간 미묘한 차이가 있는데 이는 주로 `HTTP/1.0` 과 `HTTP/1.1` 애플리케이션이 이 상태 코드를 다루는 방식의 차이점에 기인한다.



### 400-499 : 클라이언트 에러 상태 코드

가끔 클라이언트는 서버가 다룰 수 없는 무엇인가를 보낸다.

잘못 구성된 요청 메시지같은 것이 있을 수 있으며, 가장 흔한 것은 존재하지 않는 URL에 대한 요청이다.

| 상태 코드 | 사유 구절                       | 의미                                                         |
| --------- | ------------------------------- | ------------------------------------------------------------ |
| 400       | Bad Request                     | 클라이언트가 잘못된 요청을 보냈다고 말해준다.                |
| 401       | Unauthrized                     | 리소스를 얻기 전에 클라이언트에게 스스로를 인증하라고 요구하는 응답니다. |
| 402       | Payment Required                | 현재 이 상태 코드는 쓰이지 않지만, 미래에 사용될 사능성을 위해 준비되었다. |
| 403       | Forbidden                       | 요청이 서버에 의해 거부되었음을 알려주기 위해 사용한다. 만약 왜 요청이 거부되었는지 알려주고자 한다면, 서버는 그 이유를 설명하는 엔티티본문을 포함시킬수 있다. 그러나 이 코드는 보통 서버가 거절의 이유를 숨기고 싶을때 사용한다. |
| 404       | Not Found                       | 서버가 요청한 URL을 찾을 수 없을 알려주기위해 사용한다.      |
| 405       | Method Not Allowed              | 요청한 URL에 대해, 지원하지 않는 메서드로 요청받았을 때 사용한다. 요청에 'Allow' 헤더가 포함되어야 한다. |
| 406       | Not Acceptable                  | 클라이언트는 자신이 어떤 종류의 엔티티를 받아들이고자 하는지에 대해 매개변수로 명시할 수 있다. 이 코드는 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용한다. |
| 407       | Proxy Authentication Required   | 401 상태 코드와 같으나, 리소스에 대해 인증을 요구하는 프록시 서버를 위해 사용한다. |
| 408       | Request Timeout                 | 클라이언트의 요청을 완수하기에 시간이 너무 많이 걸리는 경우, 서버는 이 상태 코드로 응답하고 연결을 끊게된다. |
| 409       | Conflict                        | 요청이 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용한다. |
| 410       | Gone                            | 404 와 비슷하나, 서버가 한때 그 리소스를 갖고 있었다는 점이 다르다. 주로 웹사이트를 유지보수하면서, 서버 관리자가 클라이언트에게 리소스가 제거된 경우 이를 알려주기 위해 사용된다. |
| 411       | Length Required                 | 서버가 요청 메시지에 Content-Length 레더가 있을 것을 요구할때 사용한다. |
| 412       | Precondition Failed             | 클라이언트가 조건부 요청을 했는데 그중 하나가 실패했을 때 사용한다. |
| 413       | Request URL Too Large           | 서버가 처리 할수 있는 혹은 처리하고자 하는 한계를 넘은 크기의 요청을 클라이언트가 보냈을 때 사용한다. |
| 414       | Request URL Too Long            | 서버가 처리 할수 있는 혹은 처리하고자 하는 한계를 넘은 길이의 요청 URL이 포함된 요청을 클라이언트가 보냈을 때 사용한다. |
| 415       | Unsuppoted Media Type           | 서버가 이해하거나 지원하지 못하는 내용 유형의 엔티티를 클라이언트가 보냈을 때 사용한다. |
| 416       | Requested Range Not Satosfiable | 요청 메시지가 리소스의 특정 범위를 요청했는데, 그 범위가 잘목되거나 맞지 않을 때 사용한다. |
| 417       | Expectation Failed              | 요청에 포함된 Expect 요청 헤더에 서버가 만족시킬 수 없는 기대값이 담겨있는 경우 사용된다. 프록시나 다른 중개자 애플리케이션은, 원 서버가 요청의 기대를 만족 시킬수 없을 명확한 증거가 있다면 이 응답 코드를 전송할수 있다. |



### 500-599 : 서버 에러 상태 코드

클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생하는 경우가 있다.

이것은 클라인터가 서버의 제한에 걸린것을 수도 있도 혹은 게이트웨이 리소스와 같은 서버의 보고 구성요소에서 발행한 에러일 수도 있다.

| 상태 코드 | 사유 구절                  | 의미                                                         |
| --------- | -------------------------- | ------------------------------------------------------------ |
| 500       | Internal Server Error      | 서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용한다. |
| 501       | Not Implemented            | 클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용한다. 예를 들어 서버가 지원하지 않은 메서드를 사용한경우가 있다. |
| 502       | Bad Gateway                | 프록시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용한다. 만약 자신의 부모 게이트웨이에 접속하는 것이 불가능 할때가 있다. |
| 503       | Service Unavailable        | 현재는 서버가 요청을 처리해 줄 수 없지만 나중에는 가능함을 의미할때 사용한다. 만약 서버가 언제 그 리소스를 사용할 수 있게 될지 알리고 싶다면 Retry-After 헤더를 응답에 포함시킬 수 있다. |
| 504       | Gateway Timeout            | 408 상태 코드와 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다가 타임아웃이 발생한 게이트웨이나 타임아웃이 발생한 게이트웨이나 프록시에서 온 응답이라는 점이 다르다. |
| 505       | HTTP Version Not Supported | 서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때 사용한다. 몇몇 서버는 오래된 버전의 프로토콜을 지원하지 않는 것을 택한다. |



## 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.

헤더에 특정 종류의 메시지에서만 사용할수 있는 헤더와, 더 일반 목적으로 사용하는 헤더, 응답과 요청 모두에게 정보를 제공하는 헤더가 있다.

헤더는 크게 5가지로 구분된다.



### 일반 헤더 (General Headers)

일반 헤더는 클라이언트와 서버 양쪽 모두가 사용한다.

이들은 클라이언트, 서버, 그리고 어딘가에 메시지를 보내는 다른 애들리케이션들을 위해 다양한 목적으로 사용된다.

예를들어 Date 헤더는 서버와 클라이언트를 가리지 않고 메시지가 만들어진 일시를 지핑하기 위해 사용하는 일반 목적 헤더이다.

```http
Date: Tue, 3 Oct 1974 02:16:00 GMT
```



**일반 헤더**

어떤 헤더는 메시지에 대한 아주 기본적인 정보를 제공한다.

| 헤더                     | 설명                                                         |
| ------------------------ | ------------------------------------------------------------ |
| Connection               | 클라이언트와 서버가 요청/응답 연결에 대한 옵션을 정할 수 있게 해준다. |
| Date                     | 메시지가 언제 만들어졌는지에 대한 날짜와 시간을 제공한다.    |
| MIME-Version             | 발송자가 사용한 MIME 버전을 알려준다.                        |
| Trailer chunked transfer | 인코딩으로 인코딩된 메시지의 끝 부분에 위치한 헤더들의 목록을 나열한다. |
| Transfer-Encoding        | 수신자에게 안전한 전송을 위해 메시지에 어떤 인코딩이 적용되었는지 말해준다. |
| Upgrade                  | 발송자가 업그레이드하길 원하는 새 버전이나 프로토콜을 알려준다. |
| Via                      | 이 메시지가 어떤 중개자를 거쳐 왔는지 보여준다.              |

***MIME이란**? Multipurpose Internet Mail Extensions의 약자로 간략히 말하자면 파일 변환을 뜻한다. MIME는 이메일과 함께 동봉할 파일을 텍스트 문자로 전환해서 이메일 시스템을 통해 전달하기 위해 개발되었기 때문에 이름에 Internet Mail Extension 입니다 그렇지만 현재는 웹을 통해서 여러형태의 파일 전달하는데 쓰이고 있습니다.*



**일반 캐시 헤더**

어떤 해더는 매번 원 서버로부터 객체를 가져오는 대신 복사본으로 캐시할 수 있도록 해주는 해더(`HTTP/1.0 부터사용됨`)를 사용한다.

| 헤더          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| Cache-Control | 메시지와 함께 캐시 지시자를 전달하기 위해 사용한다. ([Cache-Control Options](####Cache-Control Options)) |
| Pragma        | 메시지와 함께 지시자를 전달하는 또 다른 방법, 캐시에 국한되지 않는다. <br />(하지만 Cache-Control로 인해 더 이상 사용되지 않을 예정 *(deprecated)* 이라고 한다.) |



### 요청 헤더 (Request Headers)

요청 메시지를 위한 헤더이다.

이들은 서버에게 클라이언트가 받고자 하는 데이터의 타입이 무엇인지와 같은 부가 정보를 제공한다.

예를들어 Accept 헤더는 서버에게 클라이언트가 자신의 요청에 대응하는 어떤 미디어 타입도 받아들일 것임을 의미한다.

```http
Accept: */*
```



먼저 서버는 요청 헤더가 준 클라이언트에 대한 그 정보를 더 나은 응답을 주기위해 활용할 수 있다.

**기본 요청 헤더**

| 헤더       | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| Client-IP  | 클라이언트가 실행된 컴퓨터의 IP를 제공한다.                  |
| From       | 클라이언트 사용자의 메일 주소를 제공한다.                    |
| Host       | 요청의 대상이 되는 서버의 호스트명과 포트를 준다.            |
| Referer    | 현재의 요청 URI가 들어있었던 문서의 URL을 제공한다.          |
| UA-Color   | 클라이언트 기기 디스플레이의 색상 능력에 대한 정보를 제공한다. |
| UA-CPU     | 클라이언트의 CPU 종류 또는 제조사를 알려준다.                |
| UA-Disp    | 클라이언트의 기스플레이 능력에 대한 정보를 제공한다.         |
| UA-OS      | 클라이언트 기기에서 동작 중인 운영체제의 이름과 버전을 알려준다. |
| UA-Pixels  | 클라이언트 기기 디스플레이에 대한 픽셀 정보를 제공한다.      |
| User-Agent | 요청을 보낸 애플리케이션의 이름을 서버에게 말해준다.         |



**Accept 요청 헤더**

클라이언트가 서버에게 자신의 선호하는바 와 능력을 알려줄수 있다.

| 헤더            | 설명                                                   |
| --------------- | ------------------------------------------------------ |
| Accept          | 서버에게 서버가 보내도 되는 미디어 종류를 말해준다.    |
| Accept-Charset  | 서버에게 서버가 보내도 되는 문자집합을 말해준다.       |
| Accept-Encoding | 서버에게 서버가 보내도 되는 인코딩을 말해준다.         |
| Accept-Language | 서버에게 서버가 보내도 되는 언어를 말해준다.           |
| TE              | 서버에게 서버가 보내도 되는 확장 전송 코딩을 말해준다. |



**조건부 요청 헤더**

때때로, 클라이언트는 요청에 몇몇 제약을 넣기도 한다.

| 헤더                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| Expect              | 클라이언트가 요청에 필요한 서버의 행동을 예상 열거할 수 있게 해준다. |
| if_Match            | 문서의 엔티티 태그가 주어진 엔티티 태그와 일치하는 경우에만 문서를 가져온다. |
| if-None-Match       | 문서의 엔티티 태그가 주어진 엔티티 테그와 일피하지 않는 경우에만 문서를 가져온다. |
| if-Modufied-Since   | 주어진 날짜 이후에 리소스가 변경되지 않았다면 요청을 제한한다. |
| if-Unmodified-Since | 주어진 날짜 이후에 리소스가 변경되었다면 요청을 제한한다.    |
| if-Range            | 문서의 특정 범위에 대한 요청을 할 수 있게 해준다.            |
| Range               | 서버가 범위 요청을 지원한다면, 리소스에 대한 범위를 요청한다. |



**보안 요청 헤더**

HTTP는 자체적으로 요청을 위한 간단한 인증요구/응갑 체계를 갖고 있다.

요청하는 클라이언트가 어느 정도의 리소스에 접근하기 전에 자신을 인증하게 함으로써 트랜젝션을 약간 더 안전하게 만들고자 한다.

| 헤더          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| Authorization | 클라이언트가 서버에게 제공하는 인증 그 자체에 대한 정보를 담고 있다. |
| Cookie        | 클라이언트가 서버에게 토큰을 전달할 때 사용한다. 진짜 보안해더는 아니지만 보안에 영향을 줄수 있다. |
| Cookie2       | 요청자가 지원하는 쿠키의 버전을 알려줄때 사용한다.           |



**프록시 요청 헤더**

인터넷에서 프록시가 점점 흔해지면서, 그들의 기능을 돕기 위해 몇몇 헤더들이 정의되었다.

| 헤더                | 설명                                                         |
| ------------------- | ------------------------------------------------------------ |
| Max-Forwards        | 요청이 원 서버로 향하는 과정에서 다른 프록시나 게이트웨이로 전달 될 수 있는 최대 횟수이다. <br />TRACE 메서드와 함께 사용된다. |
| Proxy-Authorization | Authorization 헤더와 같으나 프록시에서 인증을 할 때 쓰인다.  |
| Proxy-Connection    | Connection 과 같으나 프록시에서 연결을 맺을 때 쓰인다.       |





### 응답 해더 (Response Headers)

응답 메시지는 클라이언트에게 정보를 제공하기 위한 자신만의 헤더를 갖고있다.

```http
Server: Dan-Hut/1.0
```



**응답 헤더**

응답 메시지는 그들만의 응답 헤더를 가진다.

응답 헤더는 클라이언트에게 부가 정보를 제공하고 특별한 설명도 제공 할 수 있다.

| 헤더        | 설명                                                         |
| ----------- | ------------------------------------------------------------ |
| Age         | 응답이 얼마나 오래되었는지                                   |
| Public      | 서버가 특정 리소스에 대해 지원하는 요청 매서드의 목록        |
| Retry-After | 현재 리소스가 사용 불가능한 상태일때, 언제 가능해지는 날짜 혹은 시간 |
| Server      | 서버 애플리케이션의 이름과 버전                              |
| Title       | HTML 문서에서 주어진 것과 같은 제목                          |
| Warning     | 사유 구절에 있는것보다 더 자세한 경고 메시지                 |



**협상 응답 헤더**

서버에 프랑스어와 독일어로 번역된 HTML 문서가 있는 경우와 같이 여러가지 표현이 가능한 상황리하면, `HTTP/1.1` 은 서버와 클라이언트가 어떤 표현을 택할 것인지 협상을 지원한다.

| 헤더          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| Accept-Ranges | 서버가 자원에 대해 받아들일 수 있는 범위의 형태              |
| Vary          | 서버가 확인해 보아야 하고 응답에 영향을 줄 수 있는 헤더들의 목록<br />서버가 클라이언트에게 보내줄 리소스의 가장 적절한 버전을 선택하기 위해 살펴보야하는 헤더들의 목록 |



**보안 응답 헤더**

기본적으로 HTTP 인증요구/응답 체계에서 응답 측에 해당하는 요청

| 헤더               | 설명                                                         |
| ------------------ | ------------------------------------------------------------ |
| Proxy-Authenticate | 프록시에서 클라이언트로 보낸 인증요구의 목록                 |
| Set-Cookie         | 진짜 보안 헤더는 아니지만, 보안에 영향을 줄 수 있다.<br />클라이언트를 인증할 수 있도록 클라이언트 측에 토큰을 설정하기 위해 사용한다. |
| Set-Cookie2        | Set-Cookie와 비슷하게 RFC 2965로 정의된 쿠키 (확장 헤더이다.) |
| WWW-Authenticate   | 서버에서 클라이언트로 보낸 인증요구의 목록                   |



### 엔티티 헤더 (Entity Headers)

엔티티 헤더란 본문에 대한 헤더를 말한다. 예를 들어 엔티티 헤더는 본문에 들어있는 데이터의 타입이 무엇인지 말해줄 수 있다.

```http
Content-type : text/html; charset=iso-latin-1
```



**엔티티 헤더**

이 헤더들은 양타입의 메시지에 보두 나타날수 있다.

이는 광범위한 정보를 제공한다.

일반적으로 엔티티 헤더는 메시지의 수신자에게 자신이 다루고 있는 것이 무엇인지 말해준다.

| 헤더     | 설명                                                         |
| -------- | ------------------------------------------------------------ |
| Allow    | 이 엔티티에 대해 수행될 수 있는 요청 메서드들을 나열한다.    |
| Location | 클라이언트에게 엔티티가 실제로 어디에 위치하고 있는지 말해준다. <br />수신자에게 리소스에 대한 새로운 위치를 알려줄 때 사용된다. |



**콘텐츠 엔티티 헤더**

조금더 구체적인 정보를 제공할때 사용한다.

종류, 크기, 기타 콘텐츠를 처리하기에 매우 유용하다.

| 헤더             | 설명                                                         |
| ---------------- | ------------------------------------------------------------ |
| Content-Base     | 본문에서 사용된 상대 URL을 계산하기 위한 기저(Base) URL      |
| Content-Encoding | 본문에 적용된 인코딩                                         |
| Content-Language | 본문을 이해하는데 가장 적절한 자연어                         |
| Content-Length   | 본문의 길이나 크기                                           |
| Content-Location | 리소스가 실제로 어디에 위치하는지                            |
| Content-MD5      | 본문의 MD5 checksum                                          |
| Content-Range    | 전체 리소스에서 이 엔티티가 해당하는 범위를 바이트 단위로 표현 |
| Content-Type     | 이 본문이 어떤 종류의 객체인지                               |

***MD5**(Message-Digest algorithm 5)는 128비트 [암호화 해시 함수](https://ko.wikipedia.org/wiki/암호화_해시_함수)이다. [RFC](https://ko.wikipedia.org/wiki/RFC) 1321로 지정되어 있으며, 주로 프로그램이나 파일이 원본 그대로인지를 확인하는 무결성 검사 등에 사용된다. [1991년](https://ko.wikipedia.org/wiki/1991년)에 [로널드 라이베스트](https://ko.wikipedia.org/wiki/로널드_라이베스트)가 예전에 쓰이던 [MD4](https://ko.wikipedia.org/wiki/MD4)를 대체하기 위해 고안했다.*



**캐싱 엔티티 헤더**

일반 캐싱 헤더는 언제 어떻게 되어야 하는지에 대한 지시자를 제공한다.

인티티 캐싱 해더는 엔티티 캐싱에 대한 정보를 제공한다.

| 헤더          | 설명                                                         |
| ------------- | ------------------------------------------------------------ |
| Etag          | 이 엔티티에 대한 엔티티 테그                                 |
| Expires       | 이 엔티티가 더 이상 유효하지 않아 원본을 다시 받아와야 하는 일시 |
| Last-Modified | 가장 최근 이 엔티티가 변경된 일시                            |







### 추가 설명



#### Cache-Control Options

public

보통은 비공유 캐시 내에서만 캐시할 수 있거나(private) 캐시할 수 없지만(no-cache) public은 모든 공유/비공유 캐시에서 응답을 캐시할 수 있도록 지정합니다.



private

응답 메시지의 전체 또는 일부분을 단일 사용자만이 사용하며 절대로 공유 캐시(shared cache)에 의해 캐시해서는 안됨을 표시합니다. 원서버가 응답의 특정 부분이 단일 사용자만을 위한 것이며 다른 사용자의 요구에 대한 유효한 응답은 아니라는 것을 명시할 수 있도록 합니다.



no-cache

응답의 전체 또는 부분을 캐시해서는 안된다는 것을 나타냅니다. 원서버가 클라이언트 요구에 낡은 응답(stale response)을 리턴하도록 설정된 캐시에 의해서도 캐시를 하지 못하도록 합니다. 대부분의 HTTP/1.0 캐시는 이 지침을 인지하지 못하거나 따르지 않을 것입니다.



no-store

no-store 지시자의 목적은 부주의하게 민감한 정보를 백업테이프와 같은 곳에 보유하거나 배포하는 것을 방지하는 것입니다. no-store 지시자는 요구/응답 모두에 발송할 수 있습니다. 요구에 포함하여 발송하게 되면 캐시는 요구의 어떤 부분 또는 이 요구에 대한 어떠한 응답도 캐시해서는 안됩니다. 응답에 발송하게 되면 캐시는 이 응답의 어떤 부분 또는 응답을 이끌어 낸 요구를 저장해서는 안됩니다. 이 지시자는 비공유 및 공유 캐시에 모두 적용됩니다.



max-age

원서버는 expires 헤더를 이용하여 엔터티의 만기시간을 명시합니다. 대안으로 응답에 max-age 지시자를 사용하여 표시할 수도 있습니다.

응답에 expires 헤더 및 max-age 지시자가 모두 포함되어 있으면 max-age 지시자는 expires 헤더가 더 제한적이라 할지라도 이를 무시합니다. 이 원칙은 원서버가 HTTP/1.0 캐시에 HTTP/1.1 캐시(또는 이후 버전)보다 긴 만기시간을 응답에 부여할 수 있도록 합니다. HTTP/1.0 캐시가 동기화되지 않은(desynchronized) 시계때문에 부적절하게 경과시간이나 만기시간을 계산했을 때 유용합니다.

캐시된 사본을 원서버가 직접적으로 검증하도록 강요하여 응답을 명확히 하려면 아래와 같이 max-age 값을 0으로 지정합니다.

Cache-Control: max-age=0



must-revalidate

원서버가 계속되는 캐시 사용에 대한 캐시 엔트리 검증을 요구할 수 있는 메커니즘을 포함하고 있습니다. must-revalidate 지시자가 캐시가 수신한 응답에 포함되어 있고 캐시가 계속되는 요구에 응답하기에는 낡아진 이후에 캐시는 먼저 원서버에 이를 재검증하기 전에는 엔트리를 사용해서는 안됩니다.

must-revalidate 지시자는 특정 규약 기능의 안정된 운영을 위해서 필요합니다. 어떠한 경우이든 HTTP/1.1 캐시는 must-revalidate 지시자를 반드시 따라야 합니다.



no-transform

구현된 중간 캐시(프록시)에서 특정 엔터티 본문의 media type을 변환하는 것이 유용할 수 있습니다. 예를 들어 프록시는 캐시 공간을 절약하거나 느린 링크 상의 트래픽 양을 줄이기 위해 이미지의 포맷을 변환할 수 있습니다. 그러나 특정 종류의 애플리케이션에 사용할 엔터티 본문에 이러한 변환을 적용했을 때 심각한 운영 문제가 발생하게 됩니다. 예를 들어 의료 이미지 처리, 과학적 자료 분석 및 end-to-end 인증에 사용되는 애플리케이션은 모두 원서버의 엔터티 본문와 비트 단위까지 동일한 엔터티 본문을 수신하는 방식에 의존하고 있습니다.

따라서 응답이 no-transform 지시자를 포함하고 있으면 중간 캐시나 프록시는 Content-Encoding, Content-Length, Content-Range, Content-Type와 같은 헤더 필드 값을 절대로 변경해서는 안됩니다.



cache-extension

Cache-Control 헤더 필드는 하나 또는 그 이상의 cache-extension 토큰을 이용하여 각각 선택적으로 부여된 값을 가지고 확장할 수 있습니다. 정보 확장(informational extensions - 캐시 동작에 변화를 요구하지 않는)은 다른 지시자의 의미를 변화시키지 않고도 추가할 수 있습니다 동작 확장(behavioral extensions)은 캐시 지시자의 기본 베이스에 대한 변경자의 역할을 수행하도록 디자인 되었습니다. 새로운 지시자 및 표준 지시자 모두가 제공되었을 때 새로운 지시자를 이해하지 못하는 애플리케이션은 표준 지시자가 명시한 동작에 기본적으로 따르며 새로운 지시자를 이해하는 애플리케이션은 이를 표준 지시자와 관련된 필요 조건의 변경으로 인식합니다. 이러한 방식으로 지시자를 기본 규약에 대한 변경을 요구하지 않고도 확장할 수 있습니다.

인지할 수 없는 캐시지시자는 무시해야 합니다. HTTP/1.1 캐시가 인지하지 못하는 모든 캐시지시자는 캐시가 확장을 이해하지 못하더라도 최소한도로 이러한 캐시 동작이 정학한 것으로 유지되도록 표준 지시자(또는 응답의 캐시 제한자)와 결합되어 있다고 가정합니다.

[원문으로 돌아가기](###요청 헤더 (Request Headers))

[참조한 블로그 주소](https://joy24.tistory.com/m/101)