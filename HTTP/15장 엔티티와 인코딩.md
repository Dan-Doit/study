# 15장

HTTP는 매일 수십억 개의 미디어 객체(이미지, 텍스트, 동영상, 여러 프로그램)를 실어 나른다.

이 모든 것을 가능하게 하기 위해, HTTP는 컨텐츠를 나르기 위한 **잘 라벨링된 엔티티**를 사용한다.

우리는 이 장을 통해 먼저 어떻게 HTTP가 컨텐츠의 크기, 타입, 인코딩에 대한 필수적인 값들을 제공하는지 보여줄수있다.

또한 HTTP 엔티티, 범위요청(range request), 델타 인코딩(delta encoding), 요약(digest), 청크 인코딩을 포함한

복잡하고 강력한 기능에 대해서도 알수있다.





## 메시지는 컨테이너, 엔티티는 화물

HTTP 메시지를 인터넷 운송 시스템의 컨테이너라고 생각한다면, HTTP 엔티티는 메시지의 실질적인 화물이다.

아래는 겨우 18글자에 불과한(Content-Length: 18) 플래인 텍스트 문자이다.

```http
HTTP/1.0 200 OK
Server: Netscape-Enterprise/3.6
Date: Sun ...
Content-Type: Text/plain --- 엔티티 헤더
Content-Length: 18         
                 ----------- 빈줄 또는 CRLF (헤더 필드와 본문을 나눈다.)
Hi! I'm message! ----------- 엔티티 본문
```

우리는 다음의 몇가지 엔티티 헤더를 알수있다.

- Content-Type

  엔티티에 의해 전달된 객체의 종류

- Content-Length

  전달되는 메시지의 길이나 크기

- Content-Language

  전달되는 객체와 가장 잘 대응되는 자연어

- Content-Encoding

  객체 데이터에 대해 행해진 변형

- Content-Location

  요청 시점을 기준으로, 객체의 또 다른 위치

- Content-Range

  만약 이 엔티티가 부분 엔티티라면, 이 헤더는 이 엔티티가 전체에서 어느 부분인지 정의해준다.

- Content-MD5

  엔티티 본문의 콘텐츠에 대한 체크섬

- Last-Modified

  서버에서 이 컨텐츠가 생성 혹은 수정된날

- Expires

  이 엔티티 데이터가 더이상 신선하지 않은것으로 간주되기 시작하는 날짜와 시간

- Allow

  이 리소스에 대해 어떤 요청 메서드가 허용되는지 (GET, POST ...)

- Cache-Control

  어떻게 이 문서가 캐시될 수 있는지



### 엔티티 본문

엔티티 본문은 가공되지 않은 데이터만을 담고있다.

다른 정보들은 모두 헤더에 담겨있다.

엔티티 본문은 빈줄(CRLF) 바로 다음부터 시작한다.

다음은 텍스트 엔티티의 모습과 이미지 엔티티를 보여준다. 모두 16진수로 되어있으며 메시지의 정확한 내용을 알려준다.

![image-20220727194951479](15장 엔티티와 인코딩.assets/image-20220727194951479.png) 





## Content-Length: 엔티티의 길이



이 헤더는 메시지의 엔티티 본문의 크기를 바이트 단위로 나타낸다.

어떻게 인코딩 되었든 상관없이 크기를 표현할 수 있다.

**Content-Length 헤더는, 메시지를 청크 인코딩으로 전송하지 않는 이상, 엔티티 본문을 포함한 메시지에서는 반드시 있어야한다.**

이 값으로 커넥션 공유메시지를 올바르게 분할 할 수있기 때문이다.

- **잘림 검출**

  예전 버전의 HTTP는 커넥션이 닫힌 것을 보고 메시지가 끝났음을 인지했다.

  만약 Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌것인지 메시지 전송중 충돌이 났는지 구분하지 못한다.

  잘림 검출은 캐싱 프록시 서버에서 특히 취약하다.

  만약 캐시가 잘린 메시지를 수신하고 이를 인지하지 못하면 캐시는 결함이 있는 컨텐츠를 계속 제공할것이다.

- **잘못된 Content-Length**

  만약 이 헤더가 잘못된 값을 담고 있을 경우 아예 빠진것보다도 큰 피해를 유발할수 있다.

  초창기 클라이언트와 서버들중 일부가 Content-Length 값 계산과 관련된 버그들을 가지고 있기 떄문이다.

- **Content-Length와 지속 커넥션**

  Content-Length은 지속 커넥션을 위해 필수이다.

  만약 응답이 지속 커넥션을 통해 온 것이라면, 또 다른 HTTP 응답이 즉시 그 뒤를 잇는다.

  Content-Length 헤더는 클라이언트에게 메시지 하나가 어디서 끝나고 다음시작은 어디인지 알려준다.

- **컨텐츠 인코딩**

  HTTP는 보안을 강화하거나 압축을 통해 공간을 절약할 수 있도록, 엔티티 본문을 인코딩할 수있게 해준다.

  만약 본문의 콘텐츠가 인코딩 되어있다면 Content-Length헤더는 인코딩된 본문의 길이를 바이트 단위로 정의한다.

- **엔티티 본문 길이 판별을 위한 규칙**

  다음은 엔티티 본문의 길이와 끝나는 위치를 바르게 판별하는 규칙들이다.

  1. 본문을 갖는 것이 허용되지 않는 특정 타입의 HTTP(`HEAD요청`,`1XX 응답`,`204`,`304` 등) 메시지에서는 본문 계산을 위한 Content-Length가 무시된다. 그렇기때문에 이런 요청에 엔티티의 헤더의 끝은 첫번째 빈줄(CRLF)이 된다.
  2. 메시지가 Transfer-Encoding 헤더를 포함하고있다면, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔티티는 `0 바이트 청크` 라고 불리는 특별한 패턴으로 끝나야한다. (보통은 기본 HTTP `identity` 인코딩으로 온다.)
  3. 메시지가 Content-Length 헤더를 갖는다면 Transfer-Encoding가 존재하지 않는이상 엔티티 본문의 길이를 담고있다.
  4. 메시지가 `multipart/byteranges` 미디어 타입을 사용하고 엔티티 길이가 별도로 Content-Length 정의되어있지 않다면, 멀티파트 메시지의 각 부분은 각자가 스스로 정의할 것이다.  `multipart/byteranges` 은 자신의 크기기를 스스로 결정할수 있는 **유일한 엔티티 본문** 유형이다.
  5. 위의 규칙에 해당하지 않는다면 엔티티 커넥션이 닫힐 때 끝난다.
  6. HTTP/1.0 애플리케이션과의 호환을 위해, 엔티티 본문을 갖고있는 HTTP/1.1 요청은 반드시 유효한 Content-Length를 가지고 있어야한다. `HTTP/1.1` 명세에는 만약 요청에 본문은 있지만 Content-Length가 없다면 `400 Bad Request`응답을, 유효한 값을 요구하고 싶다면 `411 Length Required` 응답을 보내라고 조언하고있다.





## 엔티티 요약



HTTP가 일반적으로 TCP/IP와 같이 신뢰할 만한 전송 프로토콜 위에서 구현됨에도 불과하고, 완전한 트랜스코딩 프록시나 버그 많은 중개자 프록시를 비롯한 여러가지 이유로 메시지의 일부분이 전송 중에 변형되는 일이 일어난다. 엔티티 본문의 의도치 않은 변경을 감지하기 위해, 최초 엔티티 생성자는 데이터에 대한 체크섬을 생성할 수 있으며, 수신자는 모든 의도하지 않은 엔티티의 변경을 잡아내기 위해 그 체크섬으로 기본적인 검사를 할 수 있다.

Content-MD5 헤더는 서버가 엔티티 본문에 MD5 알고리즘을 적용한 결과를 보내기위해 사용된다.

오직 응답을 만든 서버만이 Content-MD5 헤더를 계산해서 보낼것이다.

중간에 있는 프록시와 캐시는 그 헤더를 변경하거나 추가하지 않는다.

클라이언트 쪽에서는 먼저 전송된 인코딩을 디코딩한 뒤 그 디코딩 된 엔티티본문에 대해 MD5를 계산해야한다.

하지만 이럼에도 불과하고 Content-MD5헤더는 자주 쓰이지는 않는다.

HTTP의 확장들은 IETF 초안으로 다른 알고리즘들을 제안했고 이 값을위해 새로운 헤더인 Want-Digest가 태어났다.

이 헤더에 품질값을 이용해 여러 요약 알고리즘들 제안하고 선호도를 지정할수 있다.





## 미디어 타입과 케릭터 셋(Charset)

Content-Type 헤더는 엔티티 본문의 MIME 타입을 기술한다.

Content-Type의 값은 인터넷 할당 번호 관리기관(Internet Assigned Numbers Authority, IANA) 에 등록된 표준화된 MIME타입이다.

| 미디어 타입                   | 설명                                                         |
| ----------------------------- | ------------------------------------------------------------ |
| text/html                     | HTML 문서                                                    |
| text/plain                    | 플레인(순수) 텍스트 문서                                     |
| image/gif                     | GIF 이미지                                                   |
| image/jpeg                    | JPEG 이미지                                                  |
| audio/x-wav                   | WAV 음향 데이터 포함                                         |
| model/vrml                    | 3차원 VRML 모델                                              |
| application/vnd.ms-powerpoint | 마이크로소프트 파워포인트 프레젠테이션                       |
| multipart/byteranges          | 여러부분으로 본문이 나뉘고, 각 부분은 전체 문서의 특정 범위(바이트)를 담고있다. |
| message/http                  | 완전한 HTTP 메시지 (TRACE 메서드)                            |

- **텍스트 메체를 위한 문자 인코딩**

  Content-Type 헤더는 내용 유형을 더 자세히 지정하기 위한 선택적 매개변수도 지원한다.

  엔티티의 비트 집합을 텍스트 파일의 글자로 변환하기위한 `charset` 이 대표적인 예이다.

  ```http
  Content-Type: text/html; charset=iso-8859-4
  ```

- **멀티파트 미디어 타입**

  MIME "멀티파트" 이메일 메시지는 서로 붙어있는 여러 개의 메시지를 포함하며, 하나의 복함 메시지로 보내진다.

  각 구성 요소는 자신에 대해 서술하는 헤더를 포함한다.

- **멀티파트 폼 제출**(404쪽 이미지)

  HTTP 폼을 채워서 제출하면, 가변 길이 텍스트 필드와 업로드 될 객체는 각각이 멀티파트 본문을 구성하는 하나의 파트가 되어 보내진다. 예를들어 하나의 본문안에 수필, 이미지, 이름, 별명등을 구분한다면 HTTP에서는 다음과 같은 본문으로 보낸다.

  ```http
  // multipart/form-data 또는 multipart/mixed
  Content-Type: multipart/form-data; boundaty=[asdsdxcasdasdsadzxcssafagas]
  ```

- **멀티파트 응답**

  범위 요청에 대한 HTTP응갑 또한 멀티파트가 될 수도 있다.

  그러한 응답은 `multipart/byteranges` 헤더 및 각각 다른 범위를 담고있는 멀티파트 본문이 함께 온다.



## 컨텐츠 인코딩

HTTP 애플리케이션은 때때로 콘텐츠를 보내기 전에 인코딩을 하여고 한다.

예를 들어, 느린 속도로 연뎔된 클라이언트에게 큰 HTML 문서를 전송하기 전에 서버는 문서를 압축할수 있다.

또는 허가 받지 않은 제 3자가 볼수 없도록 암호화하거나 뒤 섞어서 보낼수있다.

- **인코딩 과정**

  다음과 같은 과정으로 인코딩 된다.

  1. 웹서버가 원본 Content-Type 과 Content-Length 헤더를 수반한 원본 응답 메시지를 생성한다.

  2. 콘텐츠 인코딩 서버가 인코딩 메시지를 생성한다. 

     Content-Type은 같지만 Content-Length는 다르다.

  3. 서버는 Content-Encording 헤더를 인코딩된 메시지에 추가하여 이를 수신측에서 디코딩 할수 있게한다.

  4. 수신측은 받은 메시지를 디코딩 하여 원본을 얻는다.

  ```http
  HTTP/1.1 200 OK
  Date: ...
  Server: Apache/1.2.4
  Content-Length: 8888
  Content-Type: image/gif
  Content-Encoding: gzip
  
  [...]
  ```

- **인코딩 유형**

  몇가지 유형을 보도록 하자 이는 모두 IANA를 통해 표준화된다.

  | 인코딩   | 설명                                                         |
  | -------- | ------------------------------------------------------------ |
  | gzip     | GNU zip 인코딩이 적용되어있다.                               |
  | compress | 유닉스 파일 압축 프로그램인 compress가 실행되었다.           |
  | deflate  | zlib 포냇으로 압축되었다.                                    |
  | identity | 어떤 인코딩도 수행되지 않았다. (Content-Encoding 헤더가 없으면 이값으로 간주된다.) |

- **Accept-Encoding 헤더**

  클라이언트가 해독할 수 없는 방법으로 서버가 인코딩 할수 있다.

  이를 막기위해 Accept-Encoding 요청 헤더를 서버에 전달한다.

  포함하지 않는다면, 서버는 어떠한 인코딩도 받아들일수 있는것으로 간주한다. (`Accept-Encoding: *`)

  ```http
  // 예시: q값은 선호도이다.
  Accept-Encoding: compress, gzip
  Accept-Encoding: gzip;q=1.0, identity; q=0.5, *;q=0
  ```

  

## 전송 인코딩과 청크 인코딩

콘텐츠 인코딩은 콘텐츠 포멧과 긴밀하게 연관되어있다.

예를들어 텍스트파일은 gzip으로 흔히 압축하지만 이미지는 그렇지 않다.

![image-20220727204946177](15장 엔티티와 인코딩.assets/image-20220727204946177.png) 



### 안전한 전송

전송 인코딩은 다른 프로토콜에서도 네트워크를 통한 '안전한 전송'을 위해 존재했다.

HTTP에서 전송된 본문이 문제를 일으키는 경우는 몇가지 뿐이다.

- 알 수 없는 크기

  이 경우 `411 Length Required`로 처리해야한다.

- 보안

  SSL의 적용으로 현재는 인코딩으로 보안을 적용하는것은 찾아보기 힘들다.



### Transfer-Encoding 헤더

전송 인코딩을 제어하고 서술하기 위해 정의된 헤더는 두가지이다.

- Transfer-Encoding

  안전한 전송을 위해 어떤 인코딩이 메시지에 적용되었는지 알려준다.

- TE

  어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 요청 헤더에 사용한다.



### 청크인코딩

메시지를 일정 크기의 청크 여럿으로 쪼개는 인코딩이다.

서버는 각 청크를 순차적으로 보내고 이 인코딩을 사용하면 메시지를 보내기 전에 전체 크기를 알 필요가 없다.

일부버퍼에 서버쪽에서 크기를 함께 보낼수 있기때문이다.

- **청크와 지속커넥션**

  커넥션에서 Content-Length의 유무는 매우 중요하다.

  하지만 이렇게 서버에서 동적으로 생성되는 경우 보내기 전에 본문의 길이를 알아내는것은 불가능하다.

  청크 인코딩은 서버가 본문을 여러 청크로 쪼개 보낼수 있게 해줌으로써 이 딜레마에 대한 해법을 제공한다.

  중간중간 크기를 버퍼에 실어 같이 보내고 본문을 모두 보냈을 경우 크기가 0인 청크로 본문이 끝났음을 알리고 커넥션을 유지한다.

  청크는 HTTP 응답헤더 블록으로 시작해 청크 스트림(청크의 길이, 데이터) 이 이어서 온다.

  길이는 16진수로 되어있고 데이터와 CRLF로 분리된다.

  ![image-20220727210417551](15장 엔티티와 인코딩.assets/image-20220727210417551.png) 

  클라이언트 또한 청크데이터를 서버로 전송하는데 이를 서버가 받아줄지 모르기때문에 `411 Length Required` 응답으로 거절당할것을 대비하여야한다.

- **메시지의 트레일러**

  트레일러에는 본문의 컨텐츠가 먼저 생성되어야 한다거나 하는 등의 

  이유로 메시지 시작 지점에서 알수 없는 추가적인 헤더 필드를 담을수있다.

  예를들어 Content-MD5 등인데 이는 문서가 생성되기 전에 문서의 MD5를 알수 없기 때문이다.

  청크 인코딩된 메시지 다음에 오게 될 헤더들을 나열하는 Trailer 헤더를 줄수있다.



### 컨텐츠 전송과 인코딩

콘텐츠 인코딩과 전송 인코딩은 동시에 사용될 수 있다.

![image-20220801073950562](15장 엔티티와 인코딩.assets/image-20220801073950562.png) 

- 전송 인코딩의 주의사항
  - 메시지가 커넥션의 종료로 끝나는 것을 제외한 나머지에는 반드시 'chunked'를 포함해야한다.
  - 청크 전송 인코딩이 사용되었다면 마지막 전송 인코딩이 존재해야한다.
  - 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용되어야 한다.



## 시간에 따라 바뀌는 인스턴스

같은 사이트를 하루에 몇번씩 방문을 하게되면 매번 조금씩 다른 결과를 얻을수 있다.

HTTP 프로토콜은 어떤 특정한 종류의 요청이나 응답을 다루는 방법들을 정의 하는데 이를 **인스턴스 조작**이라고 부른다.

그리고 이들중 대표적인 두가지는 범위 요청과 델타 인코딩이다.

이둘 모두 클라이언트가 자신이 갖고 있는 리소스의 사본이 서버가 갖고 있는 것과 정확히 같은지 판단하고, 상황에 따라서는 새 인스턴스를 요청할 수 있는 능력을 가지는것을 요구한다.

이 요구는 다음 3가지 항목으로 기준을 명확히 해야한다.

- **신선도**

  서버는 클라이언트에게 얼마나 오랫동안 콘텐츠를 캐시하고 그것이 신선하다고 가정할 수 있는지에 대한 정보를 줄것이다.

  `Expires`나 `Cache-Control` 헤더를 통해 이러한 정보를 제공할 수있다.

  `Cache-Control` 은 실제로도 매우 강력하기 때문에 이는 단지 수명이나 유효기간 뿐 아니라 신선도를 서술하기 위해서도 사용한다.

  - 요청 헤더

    | 지시자         | 메시지 타입 | 설명                                                         |
    | -------------- | ----------- | ------------------------------------------------------------ |
    | no-store       | request     | 문서의 캐시된 사본을 반환하지 않는다. 서버로 부터 응답을 저장하지 않는다. |
    | no-cache       | request     | 서버와의 최초 재검사 없이는 문서의 캐시된 사본을 반환하지 않는다. |
    | max-age        | request     | 캐시의 문서는 명시한 나이보다 오래되어서는 절대로 안 된다.   |
    | max-stale      | request     | 문서는 서버가 정해준 만료일시가 지나면 더 이상 신선하지 않게되는데, <br />신선하지 않게된 문서는 시간이 이 지시자로 지정한 시간보다 크지 않다면 받아들인다. |
    | min-fresh      | request     | 응답은 반드시 지정한 시간만큼은 신선해야한다.                |
    | no-transform   | request     | 문서를 보내기 전에 변형되어서는 안 된다.                     |
    | only-if-cached | request     | 서버에 접근하지 말고, 캐시에 들어있는 경우에만 문서를 보내라 |

  - 응답 헤더

    | 지시자           | 메시지 타입 | 설명                                                         |
    | ---------------- | ----------- | ------------------------------------------------------------ |
    | public           | response    | 응답은 어떤 캐시로든 캐시된다.                               |
    | private          | response    | 응답은 하나의 클라이언트만 접근할 수 있는 형태로 캐시된다.   |
    | no-cache         | response    | 콘텐츠는 캐시되어 클라이언트에 제공될 수 있지만, 그전에 헤더 필드들은 반드시 제거 되어야한다. <br />만약 헤더필드가 지정되지 않으면 캐시된 사본은 절대로 서버를 통한 재검사 없이 제공되어서는 안된다. |
    | no-store         | response    | 응답은 절대로 캐시되어서는 안 된다.                          |
    | no-transform     | response    | 응답은 제공되기 전에는 어떤 식으로든 수정되어서는 안된다.    |
    | must-revalidate  | response    | 응답은 반드시 제공되기 전에 서버를 통해 재검사되어야 한다.   |
    | proxy-revalidate | response    | 공유된 캐시는 반드시 응답을 원 서버를 통해 재검사해야한다.   |
    | max-age          | response    | 문서가 캐시될 수 있고 여전히 신선하다고 간주될 수 있는 시간의 최대 길이를 정의한다.<br />개인캐시에 의해 무시될수 있다. |
    | s-max-age        | response    | 공유(share)된 캐시에 적용될 수 있는 문서의 최대 수명을 정의한다. <br />개인캐시에 의해 무시될수 있다. |

  

  - 조건부 요청

    캐시의 사본이 요청되었을 때 그것이 더 이상 신선하지 않다면 캐시는 자신이 갖고있는 사본을 신선한 것으로 만들 필요가 있다.

    캐시된 사본은 만료될수 있고, 보통의 서버는 여전히 캐시에 들어있는 신선하지 못한 사본과 같은 컨텐츠를 전송한다.

    만약 항상 이렇게 같은 사본을 다시 가져오게 된다면 네트워크 대역폭을 낭비하고, 캐시와 서버에 불필요한 부하를 야기하게 된다.

    이를 고치기 위해, HTTP 클라이언트에게 **리소스가 바뀐 경우에만 사본을 요청**하는 조건부 요청이라 불리는 특별한 요청을 할 수 있는 방법을 제공한다.

    ```http
    GET /abc.html HTTP/1.0
    If-Modified-Since: Sat, 29 Jun 2023, 14:30:00 GMT
    ```

    조건부 요청이 `If` 로 시작하는 헤더는 조건이 참일 때만 수행이된다.

    | 요청                | 검사기        | 설명                                                         |
    | ------------------- | ------------- | ------------------------------------------------------------ |
    | If-Modefied-Since   | Last-Modefied | 지난번 Last-Modefied 응답 헤더에 들어있던 시각에 마지막으로 수정된 버전이 <br />더 이상 최신버전이 아니라면 그 리소스의 사본을 보내지 않는다. |
    | If-Unmodefied-Since | Last-Modefied | 지난번 Last-Modefied 응답 헤더에 들어있던 시각에 마지막으로 수정된 버전이 <br />더 이상 수정된것이 없다면 그 리소스의 사본을 보낸다. |
    | If-Match            | Etag          | 지난번 Etag 응답 헤더에 들어있던 엔티티 태크가 같다면,<br />그 리소스의 사본을 보내지 않는다. |
    | If-None-Match       | Etag          | 지난번 Etag 응답 헤더에 들어있던 엔티티 태크가 다르다면,<br />그 리소스의 사본을 보낸다. |

  

  - 검사기

    HTTP 검사는 약한 검사, 강한 검사 두가지로 나뉜다.

    

    약한 검사는 리소스의 인스턴스를 고유하게 식별 못하는 경우도 있다.

    예를들어 객체의 리소스 크기가 같더라도 내용이 다를 수 있으므로, 바이트 개수를 세는 방식으로 동작하는 가상의 횟수 검사기는 변경이 발생했음을 약하게 검사할수 있다.

    최종변경시각은 리소스가 마지막으로 수정된 시각을 의미하지만 이 시간은 약한 검사기로 간주가된다.

    이유는 1초마다 수십번 리소스는 변경될수 있고, 수천번의 요청을 처리 하기 때문이다.
    `If-Modefied-Since, If-Unmodefied-Since` 등은 약한 검사로 취급된다.

    

    강한 검사는 언제나 고유하게 식별한다.

    예로 리소스 콘텐츠의 대한 암호 체크섬(MD5) 같은 강한 검사기이다.

    Etag 헤더는 강한 검사기로 간주되는데 서버는 매 변경마다 구분되는 값을 넣어 두기때문이다.

    `If-Match, If-None-Match` 등은 강한 검사로 취급된다.

  

  

  ### 범위 요청

  HTTP는 더 나아가, 클라이언트가 문서의 일부분이나 특정 범위만 요청할 수 있도록 해준다.

  만약 범위 요청이 없다면 용량이큰 어떤 문서를 다운받는데, 네트워크 장애로 멈춘다면 **우리는 처음부터 다시 문서**를 받아야한다.

  범위 요청을 사용하면 다운로드의 중단된 시점에서 다시 재개 할수 있다.

  ```http
  GET /abc.html HTTP/1.1
  Host: www.ddd.com
  Range: bytes=4000-
  ...
  ```

  이 예제에서 클라이언트는 처음 4000 바이트 이후의 부분을 요청하고있다.

  클라이언트가 처음의 4000 바이트만 받고 실패 했을때 사용할 수 있다.

  이는 다른 부분으로 활용되기도 하는데 다운로드 시간을 줄이기 위해 여러 요청으로 다른범위를 요청하는 클라이언트가 있다.

  이런 요청의 응답은 `Content-Type: multipart/byteranges` 로 오게될것이다.





## 델타 인코딩

만약 클라이언트가 만료된 사본을 가지고 있다면, 클라이언트는 그 페이지에 대한 최신 인스턴스를 요청한다.

만약 서버가 새로운 인스턴스를 가지고 있다면 아주 일부분만 변경되었다고 하더라도 전체 인스턴스를 보내주게 될것이다.

델타 인코딩은 객체 전체가 아닌 변경된 부분에 대해서만 통신하여 전송량을 최적화 하는 HTTP 프로토콜의 확장이다.

델타 인코딩은 일종의 인스턴스 조작인데, 어떤 객체의 특정 인스턴스들에 대한 클라이언트와 서버사이의 정보 교환에 의존하기 때문이다.

![image-20220801084024872](15장 엔티티와 인코딩.assets/image-20220801084024872.png) 

클라이언트에서는 `A-IM` 헤더(Accept-Instance-Manipulation)를 보내서 자신이 페리지에 대한 델타를 받아들일 수 있음을 알려준다.

클라이언트는 `A-IM` 헤더안에 자신이 알고 있는 델타 알고리즘을 명시한다.

| 요청       | 설명                                                         |
| ---------- | ------------------------------------------------------------ |
| A-IM       | 받아들일 수 있는 인스턴스 조작의 종류를 가리키는 클라이언트 요청헤더 |
| IM         | 요청에 적용된 인스턴스 조작의 종류를 명시하는 서버의 응답 헤더. 응답 코드가 226 IM Used 일때 이 헤더를 보낸다. |
| Delta-Base | 델타를 생성하기 위해 사용된 문서의 Etag를 명시하는 서버의 응답 해더 |

다음은 `A-IM` 과 `IM`에 사용될 수 있는 값들이다.

| 종류    | 설명                                                         |
| ------- | ------------------------------------------------------------ |
| vcdiff  | vcdiff 알고리즘을 이용한 델타                                |
| diffe   | 유닉스 diff -e 명령을 이용한 델타                            |
| gdiff   | gdiff 알고리즘을 이용한 델타                                 |
| gzip    | gzip 알고리즘을 이용한 압축                                  |
| deflate | deflate 알고리즘을 이용한 압축                               |
| range   | 현재 응답이 범위 선택에 대한 결과인 부분 콘텐츠임을 말해주기 위해 서버 응답에서 사용된다. |
| identit | 클라이언트가 identity 인스턴스 조작을 받아들일 의사가 있음을 말해주기 휘해 요청의 A-IM 에 사용된다. |

이를통해 서버측 '델타 생성기'는 예전 문서와 최신 인스턴스를 비교하는데 `A-IM`에 명시되어있는 알고리즘으로 이를 계산하게 된다.

클라이언트 쪽에서는 '델타 적용기'를 통해 받아온 데이터를 페이지에 적용한다.

문서는 클라이언트에게 반환되기 전에 압축률을 극대화하기 위해 여러번의 인스턴스 조작을 거칠수도있다.

만약 압축이 된 응답을 클라이언트에서 받으면 `IM` 응답에 명시된 값으로 압축을 풀고 얻을 델타를 페이지에 적용해야한다.



델타 인코딩은 전송 시간을 줄일 수 있지만 구현하기가 매우 까다롭다.

변경이 잦고 많은 사람이 접근하는 페이지는 항상 자신이 제공하는 페이지가 변경되는 매 순간의 사본을 모두 유지되고 있어야한다.

그래야 클라이언트가 변경하려는 순간 무엇이 최신과 달라졌는지 알 수 있기 때문이다.

문서를 제공하는 시간이 줄어든 대신, 서버는 문서의 과거 사본을 모두 유지하기위해 디스크 공간을 늘려야 할 것이다.

이는 전송량 감소로 얻은 이득을 금방 무의미 하게 만들 것이다.
