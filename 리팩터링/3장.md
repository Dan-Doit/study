# 3장

---

냄새 나면 당장 갈아라



## 1. 기이한 이름(Mysterious Name)

- 코드는 추리 소설이 아니다.
- 코드는 명료하게 표현하는 중요한 요소 중 하나는 '이름' 이다.
- **함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 각각의 무슨 일을 하고 어떻게 사용해야 하는지 명확히 알 수 있도록 엄청나게 신경 써서 이름을 지어야 한다.**
- 하지만 프로그래밍에서 이름 짓기는 가장 어렵기로 손꼽히는 두 가지 중 하나다. 그 때문에 우리가 앞으로 가장 많이 사용하는 리팩토링은 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기가 될 것이다.
- 이름 바꾸기는 단순히 이름을 다르게 표현하는 연습이 아니다.
- **마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다!**

### Solutions

- 함수 선언 바꾸기
- 변수 이름 바꾸기
- 필드 이름 바꾸기



## 2. 중복 코드(Duplicated Code)

- 똑같은 코드 구조가 여러 곳에서 반복된다면 하나로 통합하여 더 나은 프로그램을 만들 수 있다.
- 코드가 중복되면 각각을 볼 때 마다 서로 차이점은 없는지 주의 깊게 살펴봐야 하는 부담이 생긴다. 그 중 하나를 변경할 대는 다른 비슷한 함수들도 모두 살펴보고 적절히 수정해야 한다.

### Solutions

- 함수 추출하기
- 문장 슬라이드하기
- 메서드 올리기



## 3. 긴 함수(Long Function)

- 저자들의 경험에 비춰보면 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성됐다.
- 짧은 함수들로 구성된 코드베이스를 얼핏 훑으면 연산하는 부분이 하나도 없어 보인다. 코드가 끝없이 위임하는 방식으로 작성되어 있기 때문이다.
- 하지만 이런 프로그램을 수년 동안 다루다 보면 이 짧은 함수들이 얼마나 중요한지 깨닫게 된다.
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만든느 가장 확실한 방법은 좋은 이름이다. 함수 이름을 잘 지어두면 본문 코드를 볼 이유가 사라진다.
- 그러기 위해서 훨씬 적극적으로 함수를 쪼개야 한다. 주석을 달아야 할 만한 부분을 무조건 함수로 만든다. 이러한 함수 이름은 동작 방식이 아닌 의도가 드러나게 짓는다.
- 이렇게 함수로 묶는 코드는 여러 줄 일 수도 있고 단 한 줄일 수도 있다. 심지어 원래 코드보다 길어지더라도 함수로 뽑는다. 단, 함수 이름에 코드의 목적을 드러내야 한다.
- **여기서 핵심은 함수의 길이가 아닌, 함수의 목적과 구현 코드의 괴리가 얼마나 큰가다.**
- **즉, '무엇을 하는지'를 코드가 잘 설명해주지 못 할수록 함수로 만드는 게 유리하다.**
- 함수를 짧게 만드는 작업의 99%는 함수 추출하기가 차지한다. 함수 본문에서 따로 묶어 빼내면 좋은 코드 덩어리를 찾아 새로운 함수로 만드는 것이다.

### Solutions

- 함수 추출하기
- 임시 변수를 질의 함수로 바꾸기
- 매개변수 객체 만들기
- 객체 통째로 넘기기
- 함수를 명령으로 바꾸기
- 조건문 분해하기
- 조건부 로직을 다형성으로 바꾸기
- 반복문 쪼개기



## 4. 긴 매개변수 목록(Long Parameter List)

- 저자들이 프로그래밍을 시작하던 시절에는 함수에 필요한 것들을 모저리 매개변수로 전달하라고 배웠다. 그래야 암적 존재인 전역 데이터가 늘어나는 사태를 막을 수 있기 때문에 그 시절에는 합리적인 방식이었다.
- 하지만 매개변수 목록이 길어지면 그 자체로 이해하기 어려울 때가 많았다.

### Solutions

- 매개변수를 질의 함수로 바꾸기
- 객체 통째로 넘기기
- 매개변수 객체 만들기
- 플래그 인수 제거하기
- 여러 함수를 클래스로 묶기



## 5. 전역 데이터(Global Data)

- 전역 데이터를 주의해야 한다. 그렇지 않으면 크나큰 고통을 받게 된다.
- 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없다는 게 문제다. 정말 그 버그를 찾기 어렵다.
- 전역 데이터의 대표적인 형태는 전역 변수지만 클래스 변수와 싱글톤에서도 같은 문제가 발생한다.
- 이를 방지하기 위해 저자들이 사용하는 대표적인 리팩토링은 변수 캡슐화하기다. 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때 마다 이 기법을 가장 먼저 적용한다.
- 이런 데이터를 함수로 감싸는 것만으로도 데이터를 수정하는 부분을 쉽게 찾을 수 있고 접근을 통제할 수 있게 된다.

### Solutions

- 변수 캡슐화하기



## 6. 가변 데이터(Mutable Data)

- 데이터를 변경했더니 예창시 못한 결과를 낳는 골치 아픈 버그는 가변 데이터 때문일 가능성이 높다. 이러한 문제는 아주 드문 조건에서만 발생한다면 원인을 알아내기가 매우 어렵다.
- 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어 반환한다는 개념을 기본으로 삼고 있다.
- 하지만 함수형 언어가 프로그래밍에서 차지하는 비중은 여전히 적고 변수 값을 바꿀 수 있는 언어를 사용하는 프로그래머는 더 많다. 그렇다고 불변성의 장점을 포기할 필요는 없다.

### Solutions

- 변수 캡슐화하기
- 변수 쪼개기
- 문장 슬라이드하기
- 함수 추출하기
- 질의 함수와 변경 함수 분리하기
- 세터 제거하기
- 파생 변수를 질의 함수로 바꾸기
- 여러 함수를 클래스로 묶기
- 여러 함수를 변환 함수로 묶기
- 참조를 값으로 바꾸기



## 7. 뒤엉킨 변경(Divergent Change)

- 소프트웨어는 자고로 소프트해야 소프트웨어 답다.
- 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다. 이렇게 할 수 없다면 뒤엉킨 변경과 산탄총 수술 중 하나가 풍긴다.
- 뒤엉킨 변경은 단일 책임 원칙(SRP : Single Responsibility Principle)이 제대로 지켜지지 않을 때 나타난다. 즉, 하나의 모듈이 서로 다른 이유들로 인해 여러 가지 방식으로 변경되는 일이 많을 때 발생한다.

### Solutions

- 단계 쪼개기
- 함수 옮기기
- 함수 추출하기
- 클래스 추출하기



## 8. 산탄총 수술(Shotgun Surgery)

- 뒤엉킨 변경과 비슷하면서도 정반대의 경우이다.
- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다. 변경할 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.
- 이럴 때는 함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 모두 한 모둘에 묶어두면 좋다. 비슷한 데이터를 다루는 함수가 많다면 여러 함수를 클래스로 묶기를 적용한다.
- 데이터 구조를 변환하거나 보강하는 함수들에는 여러 함수를 변환 하수로 묶기를 적용한다. 이렇게 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면 단계 쪼개기를 적용한다.

### Solutions

- 함수 옮기기
- 필드 옮기기
- 여러 함수를 클래스로 묶기
- 단계 조깨기
- 함수 인라인하기
- 클래스 인라인하기



## 9. 기능 편애(Feature Envy)

- 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용할 일이 더 많을 때 풍기는 냄새다.

### Solutions

- 함수 옮기기
- 함수 추출하기



## 10. 데이터 뭉치(Data Clumps)

- 데이터 항목들은 어린아이 같은 면이 있다. 서로 어울려 노는 걸 좋아한다.
- 그래서 데이터 항목들이 여러 곳에서 항상 함께 뭉쳐 다니는 모습을 흔히 목격할 수 있다. 클래스 두어 개의 필드에서, 혹은 여러 메서드의 시그니처에서 함께 발견되기도 한다.
- 이렇게 몰려다니는 데이터 뭉치는 보금자리를 따로 마련해줘야 마땅하다.

### Solutions

- 클래스 추출하기
- 매개변수 객체 만들기
- 객체 통째로 넘기기



## 11. 기본형 집착(Primitive Obsession)

- 프로그래머 중에는 자신에게 주어진 문제에 딱 맞는 기초 타입을 직접 정의하기를 몹시 꺼리는 사람이 많다. 그래서 금액을 그냥 숫자형으로 계산하거나, 물리량을 계산할때도 밀리미터나 인치 같은 단위를 무시하고, 범위도 if (a < upper && a > lower) 처럼 처리하는 코드를 수없이 봤다. 이 냄새는 문자열을 다루는 코드에서 특히 흔하다.

### Solutions

- 기본형을 객체로 바꾸기
- 타입 코드를 서브클래스로 바꾸기
- 조건부 로직을 다형성으로 바꾸기
- 클래스 추출하기
- 매개변수 객체 만들기



## 12. 반복되는 switch문(Repeated Switches)

- 순수한 객체 지향을 신봉하는 사람들과 얘기하다보면 주제는 곧 switch문의 사악함으로 흘러간다.

  이들은 코드의 등장하는 sitch문은 모조리 **조건부 로직을 다형성으로 바꾸기** 로 없애야한다고 주장한다. 심지어 if문도 예외는 아니다.

### Solutions

- 조건부 로직을 다형성으로 바꾸기



## 13. 반복문(Loops)

- 반복문은 프로그래밍 언어가 등장할 때부터 함께 한 핵심 프로그래밍 요소이다.

  하지만 지금은 솜털 무늬 벽지보다 못한 존재가 됐다. 지금은 **일급 함수** 를 지원하는 언어가 많아졌기에 적용해서 시대에 걸 맞지 않는 반복문을 제거한다.

### Solutions

- 반복문을 파이프라인으로 바꾸기 (filter, map)



## 14. 성의 없는 요소(Lazy Element)

- 우리는 코드의 구조를 잡을 때 **요소** 를 이용하는 걸 좋아한다. 그래야 그 구조를 변형하거나 재활용할 기회가 생기고, 혹은 단순히 더 의미있는 이름을 가졌기 때문이다. 그렇지만 실제로 그 구조가 필요 없을때도 있다. 이런 구조는 나중에 본문을 더 채우거나 다른 메서드를 추가할 생각이었지만, 어떠한 사정으로 인해 그렇게 하지 못한 결과일 수 있다. 사정이 어떠하든 이런 요소는 보내드리도록 하자.

### Solutions

- 함수 인라인하기
- 클래스 인라인하기
- 계층 합치기



## 15. 추측성 일반화(Speculative Generality)

- 추측성 일반화는 우리가 민감하게 반응하는 냄새로, 바로 **"나중에 할거야"** 라는 명목으로 당장은 필요없는 모든 종류의 훅(hook)포인트와 케이스 처리를 로직에 담아 놨을때 풍기기 시작한다. 결과는 관리하기 어려운 코드가 되어버린다. 당장 걸리적거리는 코드는 눈앞에서 치워버리도록 하자.

### Solutions

- 계층 합치기
- 함수 인라인하기
- 클래스 인라인하기
- 함수 선언 바꾸기
- 죽은 코드 제거하기



## 16. 임시 필드(Temporary Field)

- 간혹 특정 상황에서만 값이 설정되는 필드를 가진 클래스도 있다. 하지만 객체를 가져올 때는 당연히 모든 필드가 채워져 있으리라 기대하는게 보통이라서, 이렇게 임시 필드를 갖도록 작성하면 코드를 이해하기 매우 어렵다.

### Solutions

- 클래스로 추출하기
- 함수 옮기기
- 특이 케이스 추가하기



## 17. 메시지 체인(Message Chains)

- 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 식으로, 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드를 말한다.

### Solutions

- 위임 숨기기
- 함수 추출하기
- 함수 옮기기



## 18. 중개자(Middle Man)

- 객체의 대표적인 기능 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화가 있다. 캡슐화는 과정에서는 위임이 자주 활용된다. 하지만 이 과정이 지나치면 문제가 된다. 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 매우 복잡해지고 수정도 힘들어진다.

### Solutions

- 중개자 제거하기



## 19. 내부자 거래(Insider Trading)

- 소프트웨어 개발자는 모듈 사이에 벽을 두껍게 새우기를 좋아한다. 그래서 모듈 사이시의 데이터 거래가 많으면 결합도가 높아진다고 투덜댄다. 일이 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리되어야한다.

### Solutions

- 함수 옮기기

- 필드 옮기기

- 위임 숨기기

- 서브클래스를 위임으로 바꾸기

- 슈퍼클래스를 위임으로 바꾸기

  

## 20. 거대한 클래스(Large Class)

- 한 클래스가 너무 많은 일을 하면 필드의 수가 상당히 늘어난다. 그리고 클래스에 필드가 너무 많으면 중복 코드가 생기기 쉽다.

### Solutions

- 클래스 추출하기
- 슈퍼클래스 추출하기
- 타입 코드를 서브클래스로 바꾸기
- 클래스 추출하기
- 슈퍼클래스 추출하기
- 타입 코드를 서브클래스로 바꾸기



## 21. 서로 다른 인터페이스의 대안 클래스들(Alternative Classes with Different Interfases)

- 클래스를 사용할 때의 큰 장점은 필요에 따라 언제든 다른 클래스로 교체할 수 있다는 것이다. 단, 교체하려면 인터페이스가 같아야한다.

### Solutions

- 함수 선언 바꾸기
- 함수 옮기기
- 슈퍼클래스 추출하기



## 22. 데이터 클래스(Data Class)

- 데이터 클래스란 데이터 필드와 게터/세터 메서드로만 구성된 클래스를 말한다. 그저 데이터 용도로만 쓰이다보니 다른 클래스가 너무 깊이까지 함부로 다룰 때가 많다.

### Solutions

- 레코드 캡슐화하기
- 세터 제거하기
- 함수 옮기기
- 함수 추출하기
- 단계 쪼개기



## 23. 상속 포기(Refused Bequest)

- 서브클래스는 보모로부터 메서드와 데이터를 물려받는다. 하지만 유산을 원치 않거나 필요없다면? 수많은 유산중에 몇개만 맏고 끝내려는 경우가 있다.

### Solutions

- 메서드 내리기
- 필드 내리기
- 서브클래스를 위임으로 바꾸기
- 슈퍼클래스를 위임으로 바꾸기



## 24. 주석(Comments)

- 주석을 달면 안 된다고 말하려는건 아니다. 주석은 악취가 아닌 향기를 입한다. 하지만 이걸 탈취제 처럼 쓰면 안된다는것이다. 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 많기 때문이다.

### Solutions

- 함수 추출하기
- 함수 선언 바꾸기
- 어서션 추가하기
- '주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요없는 코드로 리팩터링해본다.'

>주석은 나같은 건망증이 많은 개발자에게 도움이 된다.
>나중에 코드를 수정해야 하거나, 지금처럼 작성한 이유를 설명하는 용도로 달도록하자. 

