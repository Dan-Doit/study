# 12장

### 상속 다루기

---

객체 지향 프로그래밍에서 가중 유명한 특성중 하나인 상속은 다른 강력한 메커니즘처럼 이 역시 아주 유용한 동시에 오용하기 쉽다.

심지어 이 상속은 발등에 불이 떨어져야 비로소 잘못 사용했음을 알아차리는 경우가 많다.

상속은 막강한 도구지만, 잘못된 곳에서 사용되거나 나중에 환경이 변해 문제가 생기기도 한다.

이럴때를 대비하여 상속을 확실하게 공부해 놓아야한다.





## 1. 메서드 올리기

중복 코드의 제거는 중요하다. 

중복된 두 메서드가 당장은 문제없이 동작할지라도 미래에는 Bug 가 꼬이는 음식물 쓰레기로 금방 전락한다.

무언가 중복이 되었다는것은 한쪽의 변경이 다른 한쪽에는 방영되지 않을 수 있다는 위험을 항상 수반한다.

하지만 일반적으로는 중복을 찾기가 쉽지 않는것이 문제일뿐!



**메서드 올리기** 는 이런 상황에서 어울리는 리팩터링이다.

만약 메서드들의 본문 코드와 똑같을 때는 **그냥 복사**하여 메서드를 올린다.

```typescript
// 리팩터링이 필요한 코드
class Employee {...}

class Enginer extends Employee {
  get name() {...}
}

class Salesperson extends Employee {
  get name() {...}
}
```

```typescript
// 리팩터링이 적용된 코드
class Employee {
  get name() {...}
}

class Enginer extends Employee {...}
class Salesperson extends Employee {...}
```



하지만 모든 클래스가 위와같이 심플할 수는 없다.

복잡한 기능일수록 선생 단계를 거쳐야 할 때가 많다. 

예컨데 서로 다른 두 클래스의 두 메서드를 각각 매개변수화하면 궁극적으로 같은 메서드가 되기도 한다.

이런 경우레 가장 적은 단계를 거쳐 리팩터링 하려면 각각의 함수를 매개변수화 한 다음 메서드를 상속 계층의 위로 올리면된다.



### 절차

>- 똑같이 동작하는 메서드인지 면밀히 살펴본다.
>- 메서드 안에서 호출하는 다른 메서드와 참조하는 필드들을 슈퍼클래스(부모클래스)에서도 호출하고 참조할 수 있는지 확인한다.
>- 메서드 시그니처가 다르다면 함수 선언 바꾸기로 슈퍼클래스에서 사용하고 싶은 형태로 통일한다.
>- 슈퍼클래스에 새로운 메서드를 생성하고, 대상 메서드의 코드를 복사해서넣는다.
>- 정적 검사를 수행한다.
>- 서브클래스 중 하나의 메서드를 제거한다.
>- 테스트한다.
>- 모든 서브클래스의 메서드가 없어질 때까지 다른 서브 클래스의 메서드를 하나씩 제거한다.



### 예시

- 두 서브 클래스의 같은 일을 수행하는 메서드를 찾는다.

  ```typescript
  class Employee extends Party {
    get anuualCost() {
      return this.monthlyCost * 12
    }
  }
  
  class Department extends Party {
    get totalAnuualCost() {
      return this.monthlyCost * 12
    }
  }
  ```

- 확인해보니 두 메서드에서 참조하는 monthlyCost() 속성은 슈퍼클래스에는 정의 되어 있지 않지만 두 서브 클래스 모두에 존재한다.

  지금은 동적 언어인 자바 스크립트를 사용하니 괜찮다.

  정적 언어였다면 슈퍼클래스에 메서드를 정의해야한다.

- 두 메서드의 이름이 다르므로 함수 선언 바꾸기로 **이름을 통일**한다.

  ```typescript
  class Department extends Party {
    get anuualCost() {
      return this.monthlyCost * 12
    }
  }
  ```

- 서브클래스 중 하나의 메서드를 복사해 슈퍼클래스에 붙여 넣는다.

  ```typescript
  class Party {
    get annualCost() {
      return this.monthlyCost * 12
    }
    // 서브 클래스 책임 오류
    // 위의 annualCost는 현재 monthlyCost를 선언하지 않은 상태로 동작이 된다.
    // 이유는 자바 스크립트가 동적 언어이기 때문인데 아래와 같이
    // 함정 메서드를 만들어 monthlyCost를 구현해야 한다는 사실을 알려주는게 좋다.
    get monthlyCost() {
      throw new SubclassResponsibilityError();
    }
  }
  ```







## 2. 필드 올리기

서브 클래스들의 **독립적으로 개발**되었거나 뒤늦게 **하나의 계층구조로 리팩터링된 경우**라면 일부 기능이 중복되어 있을때가 왕왕있다.

특히 **필드가 중복**되기 쉽다.

이런 필드들은 이름이 비슷한게 보통이지만, 항상 그런 것은 아니다.

그래서 어떤 일이 벌어지는지를 알아내려면 필드들이 어떨게 이용되는지 분석해봐야한다.

분석 결과 비슷한 방식으로 쓰인다면 슈퍼클래스로 끌어 올리자.

```typescript
// 리팩터링이 필요한 코드
// JAVA 코드입니다.
class Employee {...}

class Enginer extends Employee {
  private String name;
}

class Salesperson extends Employee {
  private String name;
}
```

```typescript
// 리팩터링이 적용된 코드
// JAVA 코드입니다.
class Employee {
  protected String name; // Javascript에는 protected 없음 ㅠ
}

class Enginer extends Employee {...}
class Salesperson extends Employee {...}
```



### 절차

>- 후보 필드들을 사용하는 곳 모두가 그 필드들을 똑같은 방식으로 사용하는지 면밀히 살핀다.
>- 필드들의 이름이 각기 다르다면 똑같은 이름으로 바꾼다.
>- 슈퍼클래스에 새로운 필드를 생성한다.
>- 서브클래스의 필드들을 제거한다.
>- 테스트한다.



### Tip

>Private 와 Public 그리고 Protected의 차이
>
>우리가 흔히 마시는 커피를 커피 머신을 사용하면 **쉽고 간편**하게 마실 수 있다.
>
>하지만 커피머신을 해부하면 이 보다 더 복잡할 수가 없다.
>
>물론 커피머신을 만들때 이런점을 노출 시키지 않아 사용자에게 정말 필요한 버튼 몇가지만 제공을 한다.
>
>그러면 눈에 보이기에도 너무나 쉽게 뚝딱 커피를 내려 마실수 있기 때문이다.
>
>위와 마찬가지로 객체 지향언어는 **프로퍼티** 와 **메서드** 를 두 그룹으로 분류합니다.
>
>- 내부 인터페이스 - 동일한 클래스 내의 다른 메서드에선 접근할 수 있지만, 
>                             클래스 밖에선 접근할 수 없는 프로퍼티와 메서드
>- 외부 인터페이스 - 클래스 밖에서도 접근 가능한 프로퍼티와 메서드
>
>커피 머신에서 외부에서 보이는 몇 개의 버튼이 여기서는 외부 인터페이스로 불릴수 있다.
>
>그리고 안의 수많은 부품과 움직이는 동작 요소들은 내부 인터페이스를 통해 이루어진다.
>
>자바스크립트 또한 이런 요소로서 **두 가지 타입의 객체 필드**(프로퍼티와 메서드)가 있습니다.
>
>- private - 클래스 내부에서만 접근할 수 있으며 내부 인터페이스를 구성할 때 쓰입니다.
>- public - 어디서든지 접근할 수 있으며 외부 인터페이스를 구성합니다. 
>              지금까지 다룬 프로퍼티와 메서드는 모두 public입니다.
>
>또한 자바스크립트 외(자바스크립트는 지원 x)의 다수의 언어에서 **클래스 자신과 자손에게 접근 가능 기능을 내려주는** protected 필드를 지원합니다.
>
>protected 필드는 private과 비슷하지만, 자손 클래스에서도 접근이 가능하다는 점이 다릅니다. 
>
>protected 필드도 내부 인터페이스를 만들 때 유용합니다. 자손 클래스의 필드에 접근해야 하는 경우가 많기 때문에, 
>
>protected 필드는 private 필드보다 조금 더 광범위하게 사용됩니다.
>
>자바스크립트는 protected 필드를 지원하지 않지만, protected를 사용하면 편리한 점이 많기 때문에 이를 모방해서 사용하는 경우가 많습니다.
>
>### protected 프로퍼티
>
>```javascript
>class CoffeeMachine {
>  waterAmount = 0; // 물통에 차 있는 물의 양
>
>  constructor(power) {
>    this.power = power;
>    alert( `전력량이 ${power}인 커피머신을 만듭니다.` );
>  }
>}
>
>// 커피 머신 생성
>let coffeeMachine = new CoffeeMachine(100);
>
>// 물 추가
>coffeeMachine.waterAmount = 200;
>```
>
>위의 코드는 public으로 설정이 되어있기 때문에 언제나 쉽게 `waterAmount` 에 접근할 수 있습니다.
>
>`waterAmount` 의 protected를 사용하여 관리를 해보도록 하겠습니다.
>
>**protected 프로퍼티 명 앞엔 밑줄 `_`이 붙습니다.**
>
>```typescript
>class CoffeeMachine {
>  _waterAmount = 0;
>
>  set waterAmount(value) {
>    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
>    this._waterAmount = value;
>  }
>
>  get waterAmount() {
>    return this._waterAmount;
>  }
>
>  constructor(power) {
>    this._power = power;
>  }
>
>}
>
>// 커피 머신 생성
>let coffeeMachine = new CoffeeMachine(100);
>
>// 물 추가
>coffeeMachine.waterAmount = -10; // Error: 물의 양은 음수가 될 수 없습니다.
>```
>
>이제 물의 양을 0미만으로 설정 할 수 없습니다.
>
>protected 필드는 상속됩니다.
>
>`class MegaMachine extends CoffeeMachine`로 클래스를 상속받으면, 새로운 클래스의 메서드에서 `this._waterAmount`나 `this._power`를 사용해 프로퍼티에 접근할 수 있습니다.
>
>이렇게 `protected` 필드는 아래에서 보게 될 `private` 필드와 달리, 자연스러운 상속이 가능합니다.
>
>
>
>### 읽기 전용 프로퍼티 생성하기
>
>읽기 전용 프로퍼티를 만들려면 setter(설정자)는 만들지 않고 getter(획득자)만 만들어야 합니다.
>
>````javascript
>class CoffeeMachine {
>  // ...
>
>  constructor(power) {
>    this._power = power;
>  }
>
>  get power() {
>    return this._power;
>  }
>
>}
>
>// 커피 머신 생성
>let coffeeMachine = new CoffeeMachine(100);
>
>// 전력량이 100인 커피머신을 만듭니다.
>alert(`전력량이 ${coffeeMachine.power}인 커피머신을 만듭니다.`); 
>
>// Error (setter 없음)
>coffeeMachine.power = 25;
>````
>
>```javascript
>// getter와 setter 함수
>// 위에서는 get, set 문법을 사용해서 getter와 setter 함수를 만들었습니다.
>// 하지만 대부분은 아래와 같이 get.../set... 형식의 함수가 선호됩니다.
>
>class CoffeeMachine {
>  _waterAmount = 0;
>
>  setWaterAmount(value) {
>    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
>    this._waterAmount = value;
>  }
>
>  getWaterAmount() {
>    return this._waterAmount;
>  }
>}
>
>new CoffeeMachine().setWaterAmount(100);
>// 다소 길어보이긴 하지만, 이렇게 함수를 선언하면 다수의 인자를 받을 수 있기 때문에 좀 더 유연합니다(위 예시에선 인자가 하나뿐이긴 하지만요).
>
>// 반면 get, set 문법을 사용하면 코드가 짧아진다는 장점이 있습니다. 어떤걸 사용해야 한다는 규칙은 없으므로 원하는 방식을 선택해서 사용하세요.
>```
>
>
>
>### Private 프로퍼티
>
>```javascript
>class CoffeeMachine {
>  #waterLimit = 200;
>
>  #checkWater(value) {
>    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
>    if (value > this.#waterLimit) throw new Error("물이 용량을 초과합니다.");
>  }
>
>}
>
>let coffeeMachine = new CoffeeMachine();
>
>// 클래스 외부에서 private에 접근할 수 없음
>coffeeMachine.#checkWater(); // Error
>coffeeMachine.#waterLimit = 1000; // Error
>```
>
>`#`은 자바스크립트에서 지원하는 문법으로, private 필드를 의미합니다. private 필드는 클래스 외부나 자손 클래스에서 접근할 수 없습니다.
>
>private 필드는 public 필드와 상충하지 않습니다. private 프로퍼티 `#waterAmount`와 public 프로퍼티 `waterAmount`를 동시에 가질 수 있습니다.
>
>`#waterAmount`의 접근자 `waterAmount`를 만들어봅시다.
>
>````javascript
>class CoffeeMachine {
>
>  #waterAmount = 0;
>
>  get waterAmount() {
>    return this.#waterAmount;
>  }
>
>  set waterAmount(value) {
>    if (value < 0) throw new Error("물의 양은 음수가 될 수 없습니다.");
>    this.#waterAmount = value;
>  }
>}
>
>let machine = new CoffeeMachine();
>
>machine.waterAmount = 100;
>alert(machine.#waterAmount); // Error
>````
>
>protected 필드와 달리, private 필드는 언어 자체에 의해 강제된다는 점이 장점입니다.
>
>그런데 `CoffeeMachine`을 상속받는 클래스에선 `#waterAmount`에 직접 접근할 수 없습니다. `#waterAmount`에 접근하려면 `waterAmount`의 `getter`와 `setter`를 통해야 합니다.
>
>```javascript
>// private 필드는 this[name]로 사용할 수 없습니다.
>// private 필드는 특별합니다.
>// 알다시피, 보통은 this[name]을 사용해 필드에 접근할 수 있습니다.
>
>class User {
>  ...
>  sayHi() {
>    let fieldName = "name";
>    alert(`Hello, ${this[fieldName]}`); // Error
>  }
>}
>// 하지만 private 필드는 this[name]으로 접근할 수 없습니다. 
>// 이런 문법적 제약은 필드의 보안을 강화하기 위해 만들어졌습니다.
>```





## 3. 생성자 본문 올리기

생성자는 다루기 정말 까다롭다. 일반 메서드와는 많이 달라서, 나는 생성자에서 하는 일에 제약을 두는 편이다.

서브클래스들에서 기능이 같은 메서드들을 발견하면 함수 추출하기와 메서드 올리기를 

차례로 적용하면 말끔히 슈퍼클래스로 옮겨지곤 한다.

그런데 메서드가 생성자라면 스텝이 꼬인다.

생성자는 할 수 있는 일과 호출 순서에 제약이 있기 때문에 조금 다른식으로 접근해야한다.



```typescript
// 리팩터링이 필요한 코드
class Party {...}

class Enginer extends Party {
  constructor(name, id, monthlyCost) {
    super();
    this._id = id;
    this._name = name;
    this._monthlyCost = monthlyCost;
  }
}

class Salesperson extends Employee {
  private String name;
}
```

```typescript
// 리팩터링이 적용된 코드
// 리팩터링이 필요한 코드
class Party {
    constructor(name) {
    	this._name = name;
    }
}

class Enginer extends Party {
  constructor(name, id, monthlyCost) {
    super(name);
    this._id = id;
    this._monthlyCost = monthlyCost;
  }
}
```



### 절차

>- 슈퍼클래스에 생성자가 없다면 하나 정의한다. 서브클래스의 생성자들에서 이 생성자가 호출되는지 확인한다.
>- 문장 슬라이드하기로 공통 문장 모두를 super( ) 호출 직후로 옮긴다.
>- 공통 코드를 슈퍼클래스에 추가하고 서브클래스들에서는 제거한다.
>- 생성자 매개변수 중 공통 코드에서 참조하는 값들을 모두 super( )로 건넨다.
>- 테스트한다.
>- 생성자 시작 부분으로 옮길 수 없는 공통 코드에는 함수 추출하기와 메서드 올리기를 차례로 적용한다.



### 예시: 공통 코드가 나중에 올 경우

생성자는 대부분 (super( )를 호출하여) 공통 작업을 먼저 처리한 다음, 각 서브 클래스에 필요한 추가 작업을 처리하는 식으로 동작한다.

그런데 가끔 공통 작업이 뒤에 오는 경우가 있다.

```javascript
class Employee {
	constructor(name) {...}
  get isPrivileged() {...}
  assignCar() {...}
}
                      
class Manager extends Employee{
  constructor(name, grade) {
    super(name);
    this._grade = grade;
    if (this.isPrivileged) this.assignCar();
  }
  
  get isPrivileged() {
    return this._grade > 4;
  }
}
                      
```

이런 경우라면 먼저 공통 코드를 함수로 추출한다.

```javascript
class Manager extends Employee{
  constructor(name, grade) {
    super(name);
    this._grade = grade;
    this.finishConstruction();
  }
  
  get finishConstruction() {
    if (this.isPrivileged) this.assignCar();
  }
}
    
```

그런 다음 추출한 매서드를 슈퍼 클래스로 옮긴다.

```javascript
class Employee {
	constructor(name) {...}
	
  get isPrivileged() {...}
  
  assignCar() {...}
  
  finishConstruction() {
    if (this.isPrivileged) this.assignCar();
  }
}
```





## 4. 메서드 내리기

특정 서브클래스 하나와 관련된 메서드는 슈퍼클래에서 제거하고 해당 서브 클래스에 추가하는것이 깔끔하다.

하지만 이 리팩터링은 해당 기능을 제공하는 서브클래스가 정확히 무엇인지를 호출자가 알고 있을 때만 적용할 수 있다.

```typescript
// 리팩터링이 필요한 코드
class Employee {
  get name() {...}
}

class Enginer extends Employee {...}
class Salesperson extends Employee {...}
```

```typescript
// 리팩터링이 적용된 코드
class Employee {...}

class Enginer extends Employee {...}
class Salesperson extends Employee {
  get name() {...}
}
```



### 절차

>- 대상 메서드를 모든 서브클래스에 복사한다.
>- 슈퍼클래스에서 그 메서드를 제거한다.
>- 테스트한다.
>- 이 메서드를 사용하지 않는 모든 서브클래스에서 제거한다.
>- 테스트한다.







## 5. 필드 내리기

서브클래스 하나에서만 사용하는 필드는 해당 서브 클래스들로 옮긴다.

```typescript
// 리팩터링이 필요한 코드
class Employee {
  private String name;
}

class Enginer extends Employee {...}
class Salesperson extends Employee {...}
```

```typescript
// 리팩터링이 적용된 코드
class Employee {...}

class Enginer extends Employee {
    protected String name;
}

class Salesperson extends Employee {...}
```



### 절차

>- 대상 필드를 모든 서브클래스에 정의한다.
>- 슈퍼클래스에서 그 필드를 제거한다.
>- 테스트한다.
>- 이 필드를 사용하지 않는 모든 서브클래스에서 제거한다.
>- 테스트한다.







## 6. 타입 코드를 서브클래스로 바꾸기

소프트웨어 시스템에서는 비슷한 대상들을 특정 특성에 따라 구분해야 할 때가 자주있다.

예컨테 직원 담당 업무로 구분하거나(관리자, 엔지니어, 영업자 등) 주문을 시급성(급함, 보통, 여유 등)으로 구분하기도 한다.

이런 일을 다루는 수단으로는 타입 코드필드가 있다.

타입 코드는 프로그래밍 언어에 따라 열거형이거나 심볼, 문자열, 숫자등로 표현되며, 

외부 서비스가 제공하는 데이터를 다루려 할 때 딸려오는 일이 흔하다.

대부분은 타입코드만으로도 특별히 불쳔한 상황은 별로 없지만 그 이상의 무언가가 필요할때가 있다.

바로 **서브클래스가 따라올 때가 대표적**이다.

서브 클래스는 두가지 특면에서 매력적이다.

- 조건에 따라 다르게 동작하도록 해주는 다형성을 제공한다.
- 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메서드가 있을 때 발현된다.

이번 리팩터링은 대상 클래스에 직접 적용할지, 아니면 타입 코드 자체에 적용할지를 고민해야 한다.

예컨대 전자 방식이라면 직원의 하위 타입인 엔지니어를 만들것이다.

반면에 후자는 직원에게 직원 유형 '속성' 을 부여하고, 이 속성을 클래스로 정의해 엔지니어 속성과 관리자 속성 같은 서브클래스를 만드는 식이다.



### 절차

>- 타입 코드 필드를 자가 캡슐화한다.
>- 타입 코그 값 하나를 선택하여 그 값에 해당하는 서브클래스를 만든다. 
>- 타입 코드 게터 메서드를 오버라이드 하여 해당 타입 코드의 리터럴 값을 반환하게 한다.
>- 매개변수로 받은 타입 코드와 방금 만든 서브클래스를 매핑라는 선택 로직을 만든다.
>- 테스트한다.
>- 타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직 추가를 반복한다.
>- 클래스 하나가 완성될 때마다 테스트한다.
>- 타입 코드 필드를 제거한다.
>- 테스트한다.
>- 타입 코드 접근자를 이용하는 메서드 모두에 메서드 내리기와 조건부 로직을 다형성으로 바꾸기를 적용한다.



### 예시: 직접 상속할 경우

- 리팩터링이 필요한 코드

```typescript
class Employee {
	constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  
  get type() {return this._type};
  
  validateType(arg) {
    if(!["engineer", "salesperson", "manager"].includes(arg))
      throw new Error(`${arg} 라는 직원 유형이 없습니다.`)
  }
  
  toString() {return `${this._name} (${this._type})`}
}
```

- 캡슐화를 진행한다.

```typescript
class Engineer extends Employee{
  get type() {
    return "engineer";
  }
}
```

- 자바스크립크의 생성자는 객체를 반환할 수 있지만 선택 로직을 생성자에 넣으려면 필드 초기화와 로직이 꼬여 엉망이 될수 있다.
  그러니 생성자를 팩처리 함수로 바꿔서 선택로직을 담을 별도 장소를 마련한다.

```javascript
function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
  }
  return new Employee(name, type);
}
```

- 남은 유형도 같은 작업을 진행한다.

```javascript
function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
    case "salesperson": return new Salesperson(name, type);
    case "manager": return new Manager(name, type);
  }
  return new Employee(name, type);
}
```

- 모든 유형에 적용했다면 타입 코드 필드와 슈퍼클래스의 게터를 제거한다.

```javascript
class Employee {
	constructor(name, type) {
    this.validateType(type);
    this._name = name;
//  this._type = type; --- 제거
  }
    
//  get type() {return this._type}; --- 제거
  
  validateType(arg) {
    if(!["engineer", "salesperson", "manager"].includes(arg))
      throw new Error(`${arg} 라는 직원 유형이 없습니다.`)
  }
  
  toString() {return `${this._name} (${this._type})`}
}
```

- 다시 테스트한후 검증 로직도 제거한다. switch 문이 사실상 같은 검증을 수행해 주기 때문이다.

```javascript
class Employee {
	constructor(name, type) {
//  this.validateType(type); --- 제거
    this._name = name;
  }
      
//  validateType(arg) {
//    if(!["engineer", "salesperson", "manager"].includes(arg))
//    throw new Error(`${arg} 라는 직원 유형이 없습니다.`)
//  } --- 제거
  
  toString() {return `${this._name} (${this._type})`}
}
```

```typescript
function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
    case "salesperson": return new Salesperson(name, type);
    case "manager": return new Manager(name, type);
    default: throw new Error(`${type} 라는 직원 유형이 없습니다.`);
  }
  return new Employee(name, type);
}
```

- 서브클래스의 타입 코드 게터(get type( ))가 여전히 남아있다. 
  보통은 이 게터들을 제거하고 싶지만, 이 메서드를 이용하는 코드가 남아있을 수 있다.

  그 때는 `조건부 로직을 다형성`으로 바꾸기와 `메서드 내리기` 로 문제를 해결하면된다.



### 예시: 간접 상속할 경우

- 리팩터링이 필요한 코드

```typescript
class Employee {
	constructor(name, type) {
    this.validateType(type);
    this._name = name;
    this._type = type;
  }
  
  get type() {return this._type};
  
  validateType(arg) {
    if(!["engineer", "salesperson", "manager"].includes(arg))
      throw new Error(`${arg} 라는 직원 유형이 없습니다.`)
  }
  
  toString() {return `${this._name} (${this._type})`}
}
```

- 캡슐화를 진행한다.

```typescript
class Engineer extends Employee{
  get type() {
    return "engineer";
  }
}
```

- 자바스크립크의 생성자는 객체를 반환할 수 있지만 선택 로직을 생성자에 넣으려면 필드 초기화와 로직이 꼬여 엉망이 될수 있다.
  그러니 생성자를 팩처리 함수로 바꿔서 선택로직을 담을 별도 장소를 마련한다.

```javascript
function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
  }
  return new Employee(name, type);
}
```

- 남은 유형도 같은 작업을 진행한다.

```javascript
function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
    case "salesperson": return new Salesperson(name, type);
    case "manager": return new Manager(name, type);
  }
  return new Employee(name, type);
}
```

- 모든 유형에 적용했다면 타입 코드 필드와 슈퍼클래스의 게터를 제거한다.

```javascript
class Employee {
	constructor(name, type) {
    this.validateType(type);
    this._name = name;
//  this._type = type; --- 제거
  }
    
//  get type() {return this._type}; --- 제거
  
  validateType(arg) {
    if(!["engineer", "salesperson", "manager"].includes(arg))
      throw new Error(`${arg} 라는 직원 유형이 없습니다.`)
  }
  
  toString() {return `${this._name} (${this._type})`}
}
```

- 다시 테스트한후 검증 로직도 제거한다. switch 문이 사실상 같은 검증을 수행해 주기 때문이다.

```javascript
class Employee {
	constructor(name, type) {
//  this.validateType(type); --- 제거
    this._name = name;
  }
      
//  validateType(arg) {
//    if(!["engineer", "salesperson", "manager"].includes(arg))
//    throw new Error(`${arg} 라는 직원 유형이 없습니다.`)
//  } --- 제거
  
  toString() {return `${this._name} (${this._type})`}
}
```

```typescript
function createEmployee(name, type) {
  switch (type) {
    case "engineer": return new Engineer(name, type);
    case "salesperson": return new Salesperson(name, type);
    case "manager": return new Manager(name, type);
    default: throw new Error(`${type} 라는 직원 유형이 없습니다.`);
  }
  return new Employee(name, type);
}
```

- 서브클래스의 타입 코드 게터(get type( ))가 여전히 남아있다. 
  보통은 이 게터들을 제거하고 싶지만, 이 메서드를 이용하는 코드가 남아있을 수 있다.

  그 때는 `조건부 로직을 다형성`으로 바꾸기와 `메서드 내리기` 로 문제를 해결하면된다.



