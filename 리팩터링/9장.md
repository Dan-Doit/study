# 9장

---

### 데이터 조직화

데이터 구조는 프로그램에서 중요한 역할을 수행한다.

하나의 값이 여러 목적으로 사용된다면 혼란과 버그를 낳는다.

그러니 이런 코드를 발견하면 **변수 쪼개기**를 적용해 용도별로 분리하자.

다른 프로그램 요소와 마찬가지로 변수 이름을 제대로 짓는 일은 까다로우면서도 중요하다.

그래서 **변수 이름 바꾸기**와는 반드시 친해져야한다. 

한편, **파생 변수를 질의 함수로 바꾸기**를 활용하여 변수 자체를 완전히 없애는게 가장 좋은 해법일 때도 있다.

 참조인지 값인지가 헷갈려 문제가 되는 코드도 자주 볼 수 있는데, 둘 사이를 전환할때는 **참조를 값으로 바꾸기**와 **값을 참조로 바꾸기**를 사용한다.





## 1. 변수 쪼개기

### 배경

변수는 다양한 용도로 쓰인다. 그 중 변수에 값을 여러 번 대입할 수 밖에없는 경우도 있다.

예컨데 (반복문 `for (let i = 0; i < 10; i++)` 에서 변수 i 같은) 루프 변수는 반복문을 한번 돌 떄마다 값이 바뀐다.

수집 변수는 메서드가 동작하는 중간중간 값을 저장한다.

그 외에도 변수는 긴 코드의 결과를 저장했다가 나중에 쉽게 참조하려는 목적으로 흔히 쓰인다.

이런 변수에는 닶을 단 한번만 대입해야한다.

대입이 두 번 이상 이뤄진다면 여러가지 역할을 수행한다는 신호다.

역할이 둘 이상인 변수가 있다면 쪼개야 한다. 예외는 없다.

역할 하나당 변수 하나다. 여러 용도로 쓰인 변수는 코드를 읽는 이에게 커다란 혼란을 주기 때문이다.



```typescript
// 리팩터링이 필요한 코드
let temp = 2 * (height + width);
console.log(temp);

temp = height * width;
console.log(temp);
```

```typescript
// 리팩터링이 적용된 코드
const perimeter = 2 * (height + width);
console.log(perimeter);

const area = height + width;
console.log(area);
```



### 절차

- 변수를 선언한 곳과 값을 처음 대입하는 곳에서 변수 이름을 바꾼다.
- 가능하면 이때 불변으로 선언한다.
- 이 변수에 두번째로 값을 대입하는 곳 앞까지의 모든 참조를 새로운 변수 이름으로 바꾼다.
- 두번째 대입시 변수를 원래 이름으로 다시 선언한다.
- 테스트한다.
- 반복한다. 
- 매 반복에서 변수를 새로운 이름으로 선언하고 다음번 대입 때까지의 모든 참조를 새 변수명으로 바꾼다.
- 이 과정을 마지막 대입까지 반복한다.





## 2. 필드 이름 바꾸기

### 배경

이름은 중요하다.

그리고 프로그램 곳곳에서 쓰이는 레코드 구조체의 필드 이름들은 특히 더 중요하다.

데이터 구조는 프로그램을 이해하는 데 큰 역할을 한다.

수년 전 프레드 브룩스는 이런말을 했다고 한다.

>"데이터 테이블 없이 흐름도만 보여줘서는 나는 여전히 혼란스러울 것이다.
>
> 하지만 데이터 테이블을 보여준다면 흐름도는 웬만해선 필요조차 없을 것이다.
>
> 테이블만으로 명확하기 때문이다."
>
>  														- 프레드 브룩스-

요즘은 흐름도를 그리는 사람을 찾기 어렵지만 이 격언은 여전히 유효하다.

**데이터 구조는 무슨일이 벌어지는지를 이해하는 열쇠**다.



데이터 구조가 중요한 만큼 반드시 깔끔하게 관리해야한다.

다른 요소와 마찬가지로 개발을 진행할수록 데이터를 더 잘 이해하게 된다.

따라서 그 깊어진 이해를 프로그램에 반드시 반영해야한다.

우리는 이 과정을 이름으로 충분히 풀어 나갈수 있다.

```typescript
// 리팩터링이 필요한 코드
class Organization {
	get name() {...}
}
```

```typescript
// 리팩터링이 적용된 코드
class Organization {
	get title() {...}
}
```



### 절차

- 레코드의 유효 번위가 제한적이라면 필드에 접근하는 모든 코드를 수정한 후 테스트한다. 이후 단계는 필요없다.
- 레코드가 캡슐화되지 않았다면 우선 레코드를 캡슐화 한다.
- 캡슐화된 객체 안의 private 필드명을 변경하고, 그에 맞게 내부 메서드들을 수정한다.
- 테스트한다.
- 생성자의 매개변수 중 필드와 이름이 겹치는게 있다면 함수 선언 바꾸기로 변경한다.
- 접근자들의 이름도 바꿔준다.



## 3. 파생 변수를 질의 함수로 바꾸기

### 배경

가변 데이터는 소프트웨어에 문제를 일으키는 가장 큰 골칫거리에 속한다.

가변 데이터는 서로 다른 두 코드를 이상한 방식으로 결합하기도 하는데, 

예컨대 한 쪽 코드에서 수정한 값이 연쇄 효과를 일으켜 다른 쪽 코드에 원인을 찾기 어려운 문제를 야기하기도한다.

그렇다고 **가변 데이터를 완전히 배제하기란 현실적으로 불가능할 때**가 많지만, **가변 데이터의 유효 범위**를 가능한 한 좁혀야 한다.



효과가 좋은 방법으로, 값을 쉽게 계산해낼 수 있는 변수들은 모두 제거할 수 있다.

계산 과정을 보여주는 코드 자체가 데이터의 의미를 더 분명히 드러내는 경우도 자주 있으며 변뎡된 값을 깜빡하고 결과 변수에 반영하지 않는 실수를 막아준다.

여기에 합당한 예외가 있는데, **피 연산자 데이터가 불변이라면 계산 결과도 일정하므로 역시 불변**으로 만들 수 있다.

새로운 데이터 구조를 생성하는 변형 연산이라면 비록 계산 코드로 대체할 수 있더라도 그대로 두는 것도 좋다.

변형 연산에는 두 가지가 있다.

- 첫번째, 데이터 구조를 감싸며 그 데이터에 기초하여 계산한 결과를 속성으로 제공하는 객체다.
- 두번째, 데이터 구조를 받아 다른 데이터 구조로 변환해 반환하는 함수다.



```typescript
// 리팩터링이 필요한 코드
get discountedTotal () {return this_discountedTotal;}
set discount (aNumber) {
  const old = this._discount;
  this._discount = aNumber;
  this._discountedTotal += old - aNumber;
}
```

```typescript
// 리팩터링이 적용된 코드
get discountedTotal () {return this_discountedTotal;}
set discount (aNumber) {this._discount = aNumber;}
```



### 절차

- 변수 값이 갱신되는 지점을 모두 찾는다. 필요하면 변수 쪼개기를 활용해 각 갱신 지점에서 변수를 분리한다.
- 해당 변수의 값을 계산해주는 함수를 만든다.
- 해당 변수가 사용되는 모든 곳에 어서션을 추가하여 함수의 계산 결과가 변수의 값과 같은지 확인한다.
- 테스트한다.
- 변수를 읽는 코드를 모두 함수 호출로 대체한다.
- 테스트한다.
- 변수를 선언하고 갱신하는 코드를 죽은 코드 제거하기로 없앤다.



## 4. 참조를 값으로 바꾸기

### 배경

객체를 다른객체에 중첩하면 내부 객체를 참조 혹은 값으로 취급할수 있다.

참조냐 값이냐의 차이는 내부 객체의 속성을 갱신하는 방식에서 가장 극명하게 드러난다.

참조로 다루는 경우에는 내부 객체는 그대로 기존 내부 객체를 통째로 대체한다.

필드를 값으로 다룬다면 내부 객체의 클래스를 수정하여 값 객체로 만들 수 있다.

값 객체는 대체로 자유롭게 활용하기 좋은데, 특히 불변이기 때문이다.

일반적으로 불변 데이터 구조는 다루기 더 쉽다.

불변 데이터 값은 프로그램 외부로 건네줘도 나중에 그 값이 나 몰래 바뀌어서 내부에 영향을 줄까 염려하지 않아도 된다.

값을 복제해 이곳저곳에서 사용하더라도 서로간의 참조를 관리하지 않아도 된다.

그래서 **값 객체는 분산 시스템과 동시성 시스템에서 특히 유용하다.**

```typescript
// 리팩터링이 필요한 코드
class Product {
	applyDiscount(arg) {this._price.amount -= arg;}
}
```

```typescript
// 리팩터링이 적용된 코드
class Product {
	applyDiscount(arg) {
		this._price = new Money(this._price.amount - arg, this._price.currency);
	}
}
```



### 절차

- 후보 클래스가 불변인지, 혹은 불변이 될 수 있는지 확인한다.
- 각각의 세터를 하나씩 제거한다.
- 이 값 객체의 필드들을 사용하는 동치성비교 메서드를 만든다.



## 5. 값을 참조로 바꾸기

### 배경

하나의 데이터 구조안에 논리적으로 똑같은 제 3의 데이터 구조를 참조하는 레코드가 여러개있을 때가 있다.

예컨데 주문 목록을 읽다 보면 같은 고객이 요청한 주문이 여러 개 섞여 있을 수 있다.

이때 고객을 값으로도, 혹은 참조로도 다룰 수 있다.

값으로 다룬다면 고객 데이터가 각 주문에 복사되고, 참조로 다룬다면 여러 주문이 단 하나의 데이터 구조를 참조하게 된다.

고객 데이터를 갱신할 일이 없다면 어느 방식이든 상관없다.

같은 데이터를 여러 벌 복사하는 게 조금 꺼림칙할지 모르지만, 별달리 문제되는 경우는 많지 않아서 흔히 사용하는 방식이다.

복사본이 많이 생겨서 가꿈은 메모리가 부족할 수도 있지만, 다른 성능 이슈와 마찬가지로 아주 드문일이다.

논리적으로 같은 데이터를 물리적으로 복제해 사용할 때 가장 크게 문제되는 상황은 그 데이터를 생신해야 할 때다.

모든 복제본을 찾아서 빠짐없이 생신해야 하며, 하나라도 놓치면 데이터 일관성이 깨져버린다.

이런 상황이라면 복제된 데이터들을 모두 참조로 바꿔주는 게 좋다.

데이터가 하나면 갱신된 내용이 해당 고객의 주문 모두에 곧바로 반영되기 때문이다.



```typescript
let customer = new Customer(customerData);
```

```typescript
let customer = customerRepository.get(customerData.id);
```



### 절차

- 같은 부류에 속하는 객체들을 보관할 저장소를 만든다.
- 생성자에서 이 부류의 객체들 중 특정 객체를 정확히 찾아내는 방법이 있는지 확인한다.
- 호스트 객체의 생성자들을 수정하여 필요한 객체를 이 저장소에서 찾도록 한다.
  하나 수정할 때마다 테스트한다.





