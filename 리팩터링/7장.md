# 7장

---

 

## 1. 레코드 캡슐화하기

'가변' 데이터일 때 객체를 선호한다. 이런 경우에는 우리는 해시맵으로 객체를 표현하는데 프로그램에서 해시맵을 쓰는 부분이 적다면 괜찮지만, 많아진다면 불분명함으로 인해 문제가 발생하곤한다. 그럴바에는 차라리 클래스를 사용하는 편이 낫다.

### 	절차

>- 레코드를 담은 변수를 캡슐화한다.
>- 레코드를 감싼 단순한 클래스로 해당 변수의 내용을 교체한다. 이 클래스에 원본 레코드를 반환하는 접근자도 정의하고, 변수를 캡슐화하는 함수들이 이 접근자를 사용하도록 수정한다. (get)
>- 테스트한다.
>- 원본 레코드 대신 새로 정의한 클래스 타입의 객체를 반환하는 함수들을 새로 만든다.
>- 레코드를 반환하는 예전 함수를 사용하는 코드를 4번에서 만든 새 함수를 사용하도록 바꾼다. 필드에 접근할 때는 객체의 접근자를 사용한다. 적절한 접근자가 없다면 추가한다. 한 부분을 바꿀 때 마다 테스트한다.
>- 클래스에서 원본 데이터를 반환하는 접근자와 (1에서 검색하기 쉬운 이름을 붙여둔) 원본 레코드를 반환하는 함수들을 제거한다.
>- 테스트한다.
>- 레코드의 필드도 데이터 구조인 중첩 구조라면 레코드 캡슐화하기와 컬렉션 캡슐화하기를 재귀적으로 적용한다.



## 2. 컬렉션 캡슐화하기

화자는 '가변' 데이터를 모두 캡슐화하는 편이다. 그러면 데이터 구조가 언제 어떻게 수정되는지 파악하기 쉬워서 필요한 시점에 데이터 구조를 변경하기도 쉬워지기 때문이다. 

	### 	절차

>- 아직 컬렉션을 캡슐화하지 않았다면 변수 캡슐화하기 부터 한다.
>- 컬렉션에 원소를 추가/제거하는 함수를 추가한다.
>- 정적 검사를 수행한다.
>- 컬렉션을 참조하는 부분을 모두 찾는다. 컬렉션의 변경자를 호출하는 코드가 모두 앞에서 추가한 추가/제거 함수를 호출하도록 수정한다. 하나씩 수정할 때마다 테스트한다.
>- 컬렉션 게터를 수정해서 원본 내용을 수정할 수 없는 읽기 전용 프락시나 복제본을 반환하게 한다.
>- 테스트한다.





