# 이팩티브 타입스크립트

Effective TypeScript를 읽으며 배운점과 느낀점을 정리합니다.

---



> 누가 순서도를 보여주면서 테이블을 감춘다면 나는 여전히 갸우뚱할 것이다.
>
> 하지만 테이블을 보여 준다면 순서도는 별로 필요하지 않다.
>
> 보지 않더라도 명백할 것이기 때문이다.



**맨먼스 미신**의 저자 프레드 브룩스의 이말은 오래되었지만, 지금까지 유효하다.

연산이 이루어지는 데이터나 데이터 타입을 알 수 없다면 코드를 이해하기 어렵다.

타입 스스템의 큰 장점중 하나는 데이터 타입을 명확히 알 수 있어 코드를 이해하기 쉽다는것이다.



## item 28.

### 유효한 상태만 표현하는 타입을 지향하기



타입을 잘 설계하면 코드는 직관적으로 작성할 수 있습니다.

그러나 타입 설계가 엉망이라면 어떠한 기억이나 문서도 도움이 되지 못합니다.

코드는 뒤죽박죽이 되고 버그는 창궐하게 됩니다.

효과적으로 타입을 설계하려면, 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 가장 중요합니다.

다음 예제를 한번 보도록 합시다.

```typescript
interface State {
	pageText: string;
	isLoading: boolean;
	error?: string;
}
```

페이지를 그리는 renderPage 함수를 작성할 때는 상태 객체의 필드를 전부 고려해서 상태 표시를 분기해야합니다.

```typescript
function renderPage(state: State) {
  if(state.error) {
    return "error!";
  } else if(state.isLoading) {
    return "loading!";
  }
  return "render!"
}
```



코드를 살펴보면 분기 조건이 명확히 분리되어 있지 않다는 것을 알 수 있습니다.

`isLoading`이` true`이고 동시에 `error`값이 존재하면 로딩 중인 상태인지 오류가 발행한 상태인지 명확히 구분할 수 없습니다.

필요한 정보가 부족하기 때문입니다.

다음은 페이지를 바꾸는 함수입니다.

```typescript

async function changePage(state:State, newPage: string){
  state.isLoading = true;
  try {
    const response = await fetch(getUrlForPage(newPage));
    if (!response.ok) {
      throw new Error("error!")
    }
    const text = await response.text();
    state.isLoading = false;
    state.pageText = text;
  } catch (e) {
    state.error = '' + e
  }
}
```

changePage 에는 많은 문제점이 있습니다.

몇 가지 정리해 보면 다음과 같습니다.

- 오류가 발생했을 때 state.isLoading을 false로 설정하는 로직이 빠져 있습니다.
- State.error를 초기화하지 않았기 때문에, 페이지 전환 중에 로딩 메시지 대신 과거의 오류 메시지를 보여 주게 됩니다.
- 페이지 로딩중에 사용자가 페이지를 바꿔 버리면 어떤 일이 벌어질지 예상하기 어렵습니다.
  새 페이지에 오류가 뜨거나, 응답이 오는 순서에 따라 두번째 페이지가 아닌 첫 번째 페이지로 전환될 수도 있습니다.

문제는 바로 상태 값의 두 가지 속성이 동시에 정보가 부족하거나 (요청이 실패한 것인지 여전히 로딩 중일 수 있습니다), 

두가지 속성이 충돌 (오류이면서 동시에 로딩 중일 수 있습니다) 할 수 있다는 것입니다.

State타입은 isLoading이 true이면서 동시에 error값이 설정되는 무효한 상태를 허용합니다.

무효한 상태가 존재하면 render( ), changePage( ) 둘 다 제대로 구현할 수 없게됩니다.



다음은 애플리케이션의 상태를 좀 더 제대로 표현한 방법입니다.

```typescript
interface RequestPending {
  state: 'pending'
}

interface RequestError {
  state: 'error';
  error: string;
}

interface RequestSuccess {
  state: 'ok';
  pageText: string;
}

type RequestState = RequestPending | RequestError | RequestSuccess

interface State {
  crrentPage: string;
  request: {[page: string]: RequestState};
}
```



여기서는 네트워크 요청 과정 각각의 상태를 명시적으로 모델링하는 태그된 유니온 (또는 구별된 유니온) 이 사용되었습니다.

이번 예제는 상태를 나타내는 타입의 코드 길이가 서너 배 길어지긴 했지만, 무효한 상태를 허용하지 않도록 크게 개선되었습니다.

현재 페이지는 발생하는 모든 요청의 상태로서 명시적으로 모델링되었습니다.

그 결과로 개션된 renderPage와 changePage 함수는 쉽게 구현할 수 있습니다.



