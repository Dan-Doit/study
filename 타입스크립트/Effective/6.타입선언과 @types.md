# 이팩티브 타입스크립트

Effective TypeScript를 읽으며 배운점과 느낀점을 정리합니다.

---



모든 언어들에서 라이브러리 의존성 관리는 어려운 일입니다.

여기서는 타입스크립트에서 의존성이 어떻게 동작하는지 설명하여 의존성에 대한 개념을 잡을 수 있게 도와줍니다.

재대로 된 타입 선언문을 작성하여 공개하는 것은 프로젝트뿐만 아니라 타입스크립트 전체 커뮤니티에 기여하는 일이기도 합니다.



## Item 45.

### devDependencies에 typescript와 @types 추가하기

npm(node package manager)은 자바스크립트 세상에서 필수적입니다.

npm은 자바스크립트 라이브러리 저장소(npm 레지스트리)와, 프로젝트가 의존하고 있는 라이브러리들의 버전을 지정하는 방법(apckage.json)을 제공합니다.

npm은 세 가지 종류의 의존성을 구분해서 관리하며, 각각의 의존성은 package.json파일 내의 별도 영역에 들어있습니다.



- depenencies

  현재 프로젝트를 실행하는데 필수적인 라이브러리들이 포함됩니다.
  프로젝트의 런타임에 lodash가 사용된다면 dependencies에 포함되어야 합니다.

  프로젝트를 npm에 공개하여 다른 사용자가 해당 프로젝트를 설치한다면, dependecies에 들어 있는 라이브러리도 함께 설치될 것입니다.
  이러한 현상을 전이(transitive) 의존성이라고 합니다.

- devDependencies

  현재 프로젝트를 개발하고 테스트하는 데 사용되지만, 런타임에는 필요 없는 라이브러리들이 포함됩니다.
  예를 들어, 프로젝트에서 사용 중인 테스트 프레임워크가 devDependencies에 포함될 수 있는 라이브러리입니다.
  프로젝트를 npm에 동개하여 다른 사용자가 해당 프로젝트를 설치한다면, devDependencies에 포함된 라이브러리들은 제외된다는 것이 dependencies와 다른점입니다.

- peerDependencies

  런타임에 필요하긴 하지만, 의존성을 직접 관리하지 않는 라이브러리들이 포함됩니다.
  단적인 예로 **플러그인**을 들 수 있습니다.
  제이쿼리의 플러그인은 다양한 버전의 제이쿼리와 호완이되므로 제이쿼리의 버전을 플러그인에서 직접 선택하지 않고, 
  플러그인이 사용되는 실제 프로젝트에서 선택하도록 만들 때 사용합니다.



이 세 가지 의존성 중에서는 dependencies와 devDependencies가 일반적으로 사용됩니다.

타입스크립트 개발자라면 라이브러리를 추가할 때 어떤 종류의 의존성을 사용해야 하는지 알고 있어야 합니다.

타입스크립트는 개발 도구일 뿐이고 타입 정보는 런타임에 존재하지 않기 때문에, **타입스크립트와 관련된 라이브러리는 일반적으로devDependencies에** 속합니다.



모든 타입스크립트 프로젝트에서 공통적으로 고려해야 할 의존성 두가지를 살펴보겠습니다.

- 타입스크립트 자체 의존성을 고려하자

  타입스크립트 시스템 레벨로 설치할 수도 있지만, 다음 두가지 이유 떄문에 추천하지는 않습니다.

  - 팀원들 모두가 항상 동일한 버전을 설치한다는 보장이 없습니다.
  - 프로젝트 셋업할 때 별도의 단계가 추가됩니다.

  **따라서 타입스크립트를 시스템 레벨로 설치하기보다는 devDependencies에 넣는 것이 좋습니다.**
  devDependencies에 포함되어 있다면, npm install을 실행할때 팀원들 모두 항상 정확한 버전의 타입스크립트를 설치 할수 있습니다.
  그리고 타입스크립트 버전 업데이트는 다른 라이브러리의 업데이트와 같은 방법을 사용하게 됩니다.
  대부분의 타입스크립트 IDE와 빌드 도구는 decDependencies를 통해 설치된 타입스크립트의 버전을 인식할 수 있도록 되어있습니다.
  또한 커맨드 라인에서 npx를 사용해서 devDependencies를 통해 설치된 타입스크립트 컴파일러를 실행할 수 있습니다.

  ```bash
  $ npx tsc
  ```

- 타입 의존성(@types)을 고려해야합니다.
  사용하려는 라이브러리에 타입 선언이 포함되어 있지 않더라도, 
  DefinitelyTyped(타입스크립트 커뮤니티에서 유지보수하고 있는 자바스크립트 라이브러리의 타입을 정의한 모음) 에서 타입정보를 얻을수 있습니다.
  DefinitelyTyped의 타입 정의들은 npm 레지스트리의 @types 스코프에 공개됩니다.
  즉, @types/jquery에는 제이쿼리의 타입정의가 있고, @types/lodash에는 로대시의 타입 정의가 있습니다.
  @types 라이브러리는 타입 정보만 포함하고 있으며 구현체는 포함하지 않습니다.

  원본 라이브러리 자체가 dependevcies에 있더라도 @types 의존성은 devDependencies에 있어야 합니다.
  예를 들어, 리액트의 타입선언과 리액트를 의존성에 추가하려면 다음처럼 실행합니다.

  ```bash
  $ npm install react
  $ npm install --save-dev @types/react
  ```

  그러면 다음과 같은 package.json 파일이 생성됩니다.

  ```json
  {
  	"devDependencies" : {
  		"types/react": "^16.8.19",
  		"typescript": "^3.5.3"
  	},
  	"dependencies": {
  		"react": "^16.9.6"
  	}
  }
  ```

  이 예제의 의도는 런타임의 @types/react와 typescript에 의존하지 않겠다는 것입니다.

  그러나 타입 의존성을 devDependencies에 넣는 방식이 항상 유효한 것은 아니며 @types 의존성과 관련된 몇가지 문제점이 있습니다.



### 요약

- 타입스크립트를 시스템 레벨로 설치하면 안 됩니다. 타입스크립트를 프로젝트의 devDependencies에 포함시키고 팀원 모두가 동일한 버전을 사용하도록 해야 합니다.
- @types 의존성은 dependencies가 아니라 devDependencies에 포함시켜야 합니다. 런타임에 @types가 필요한 경우라면 별도의 작업이 필요할 수 있습니다.



## Item 46.

### 타입 선언과 관련된 세가지 버전 이해하기

의존성 관리는 개발자에게 매우힘든일입니다.

그래서 우리는 아마 단순히 라이브러리를 프로젝트에 추가해서 사용할 뿐 라이브러리의 전이적 의존성이 호환되는지는 깊게 생각하지 않습니다.

그런데 실제로 타입스크립트는 알아서 의존성 문제를 해결해주기는 커녕, 의존성 관리를 오히려 더 복잡하게 만듭니다.

왜냐하면 타입스크립트를 사용하면 다음 세가지 사항을 추가로 고려해야하기 때문입니다.

- 라이브러리의 버전
- 타입선언(@types)의 버전
- 타입스크립트의 버전

세가지 버전중 하나라도 맞지 않으면, 의존성과 상관없어 보이는 곳에서 엉뚱한 오류가 발생할 수있습니다.

이렇게 발생한 오류의 원인을 파락하고 고치기 위해서는 타입스크립트 라이브러리 관리의 복잡한 메커니즘을 모두 이해해야합니다.

라이브러리 관리의 메커니즘을 이해하게 된다면 프로젝트 내에서 작성한 타입선언을

외부에 공개해야하는 시점이 되었을 때, 버전과 관련해서 재대로 된 결정을 내릴 수 있습니다.

타입스크립트에서 일반적으로 의존성을 사용하는 방식은 다음과 같습니다.

특정 라이브러리를 dependencies로 설치하고, devDependencies로 설치합니다.

```bash
$ npm install react
+ react@16.8.6

$ npm install --save-dev @types/react
+ @types/react@16.8.19
```



메이저 버전과 마이너 버전(16.8)이 일치하지만 패치 버전(.6과 .19)은 일치 하지 않는다는 점에 주목할 필요가 있습니다.

@types/react의 16.8.19는 타입선언 들이 리엑트 16.8버전의 API를 나타낸다는 것을 의미합니다.

만약 리액트 모듈이 시맨틱(simantic) 버전 규칙을 제대로 지킨다고 가정하면 패치 버전들은 공개 API의 사양을 변경하지 않습니다.

따라서 타입 선언을 업데이트할 필요가 없습니다.

그러나 타입 선언 자체에도 버그나 누락이 존재할 수 있으며 @types 모듈의 패치 버전은 버그나 누락으로 인한 수정과 추가에 따른 것입니다.

앞선 예제의 경우 라이브러리 자체보다 타입 선언데 더 많은 업데이트가 있었습니다. (19대 6)



그러나 실제 라이브러리와 타입정보의 버전이 별도로 관리되는 방식은 다음 4가지 문제점이 있습니다.

- 라이브러리를 업데이트 했지만 실수로 타입 선언은 업데이트 하지 않는경우

  - 문제점

    이런경우 라이브러리 업데이트와 관련된 새로운 기능을 사용하려 할 때마다 타입 오류가 발생합니다.
    특히 하위 호환성이 깨지는 변경이 있었다면, 코드가 타입 체커를 통과하더라도 런타임 에러가 발생할 수 있습니다.

  - 해결책

    타입선언도 업데이트하여 라이브러리와 버전을 맞춥니다.

    만약 업데이트해야할 타입선언이 준비되지 않았다면 보강(augmentation) 기법을 활용하여, 사용하려는 새 함수와 메서드의 타입 정보를 프로젝트 자체에 추가합니다.

    또는 선언의 업데이트를 직접 작성하고 공개하여 커뮤니티에 기여하는 방법입니다.

- 라이브러리보다 타입 선언의 버전이 최신인 경우입니다.

  - 문제점

    보통 타입 정보 없이 라이브러리를 사용해 오다가 타입 선언을 설치하려고 할때 뒤늦게 발생됩니다.

    그 사이에 라이브러리와 타입 선언의 새 버전이 릴리스되었다면 라이브러리와 타입 선언의 버전 정보는 어긋나게 됩니다.

    첫번째 상황과 비슷하지만 문제점의 버전의 대소 관계가 반대가 됩니다.

  - 해결책

    버전의 정보를 사용하는 라이브러리와 맞춥니다.

- 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요한 타입스크립트 버전이 최신인 경우입니다.

  - 문제점

    일반적으로 로대시, 리액트, 람다 같은 유명 자바스크립트 라이브러리의 타입 정보를 더 정확하게 표현하기 위해서

    타입스크립트에서 타입 시스템이 개선되고 버전이 올라가게됩니다.

    그러므로 이러한 라이브러리들의 최신 타입 정보를 얻기 위해서라면 당연히 타입스트립트의 최신버전을 사용해야합니다.

    현재 프로젝트보다 라이브러리에게 필요한 타입스크립트 버전이 높은 상황이라면, @types 선언 자체에서 타입오류가 발생하게 됩니다.

  - 해결책

    프로젝트의 타입스크립트 버전을 올립니다.

    라이브러리 타입 선언의 버전을 원래대로 내립니다.

    declare module 선언으로 라이브러리의 타입 정보를 없애 버립니다.

    라이브러리에서 typesVersions를 통해 타입스크립트 버전별로 다른 타입 선언을 제공하는 방법도 있지만 실제로는 매우 드뭅니다.

    최근까지도 DefinitelyTyped의 라이브러리들중 1% 미만에서만 typesVersions을 제공합니다.

    특정 버전의 타입정보 설치는 다음처럼 합니다.

    ```bash
    $ npm install --save-dev @types/lodash@ts3.1
    ```

    라이브러리와 타입 선언을 일치 시키는것이 최선이겠지만, 상황에 따라 해당 버전의 타입 정보가 없을 수도 있습니다.

    그러나 유명한 라이브러리일수록 버전별로 타입 선언이 존재할 가능성이 높습니다.

- @types 의존성이 중복될 수도 있습니다.

  - 문제점

    @types/foo 와 @types/bar에 의존하는 경우를 가정해 봅시다.

    만약 @types/bar가 현재 프로젝트와 호환되지 않는 버전의 @types/foo에 의존한다면 npm은 중첩된 폴더에 별도로 해당 버전을 설치하여 문제를 해결하고자 합니다.

    ```json
    node_modules/
    	@types/
    		foo/
    			index.d.ts @1.2.3
        bar/
        	index.d.ts
        		node_modules
        			@types/
        				foo/
        					index.d.ts @2.3.4
    ```

    런타임에 사용되는 모듈이라면 괜찮을 수 있지만, 전역 네임스페이스에 있는 타입 선언 모듈이라면 문제가 될수 있습니다.

    전역 네임스페이스에 타입 선언이 존재하면 중복된 선언, 또는 선언이 병합될 수 없다는 오류로 나타나게 됩니다.

    이런 상황이라면 다음의 명령으로 타입선언 중복이 어디서 발생했는지 알 수 있습니다.

    ```bash
    $ npm ls @types/foo
    ```

  - 해결책

    @types/foo를 업데이트하거나 @types/bar를 업데이트해서 서로 버전이 호환되게 하는것입니다.

    그러나 @types이 전이(transitive) 의존성을 사지고록 만드는 것은 종종 문제를 일으키기도 합니다.



일부 라이브러리, 특히 타입스크립트로 작성된 라이브러리들은 자체적으로 타입선언을 포함 (번들링)하게 됩니다.

자체적인 타입 선언은 보통 package.json의 "types"필드에서 d.ts 파일을 가리키도록 되어있습니다.

```json
{
	"name": "left-pad",
	"version": "1.3.0",
	"description": "~~~~",
	"main": "index.js",
	"types": "index.d.ts",
	// ..
}
```

"types": "index.d.ts"를 추가한다고 해서 모든 문제가 해결되지는 않습니다.

번들링하여 타입 선언을 포함하는 경우, 특히 라이브러리가 타입스크립트로 작성되고 컴파일러를 통해 타입선언이 생성된 경우라면 

버전 불일치 문제를 해결할 수있지만, 번들링 방식은 부수적인 4가지 문제점을 가지고 있습니다.

- 번들된 타입 선언에 보강 기법으로 해결할 수 없는 오류가 있는 경우, 또는 공개 시점에는 잘 동작했지만 타입스크립트 버전이 올라가면서 오류가 발생하는 경우

  @types을 별도로 사용하는 경우라면 라이브러리 자체의 버전에 맞추어 선택할 수 있습니다.

  그러나 번들괸 타입에서는 @types의 버전 선택이 불가능합니다.

  단 하나의 잘못된 타입 선언으로 인해 타입과 DefinielyTyped이 비교되는 부분입니다.

- 프로젝트 내의 타입선언이 다른 라이브러리의 타입선언에 의존한다면 문제가됩니다.

  보통은 의존성이 devDependencies에 들어갑니다.

  그러나 프로젝트를 공개하여 다른 사용자가 설치하게 되면 devDependencies가 설피되지 않을 것이고 타입 오류가 발생하게됩니다.

  반면 자바스크립트 사용자 입장에서는 @types를 설치할 이유가 없기 때문에 dependencies에 포함하고 싶어하지 않을것입니다.

- 프로젝트의 과거 버전에 있는 타입선언에 문제가 있는 경우에는 과거 버전으로 돌아가서 패치 업데이트를 해야합니다.

  번들링된 타입 선언에서는 어려운 일이지만, DefinitelyTyped는 커뮤니티에서 관리되기 때문에 이러한 작업량을 감당할 수있습니다.

  만약 어떤 라이브러리의 유지보수 담당자가 패치를 하게되면 개별 프로젝트에서는 비슷한 처리 시간을 보장하기 어렵습니다.



타입스크립트에서 의존성을 관리한다는것은 쉽지 않은 일이지만, 잘 관리한다면 그에 따른 보상이 함께 존재합니다.

잘 작성된 타입 선언은 라이브러리를 올바르게 사용하는 방법을 배우는 데 도움이 되며 생산성 역시 크게 향상시킬수 있습니다.



### 요약

- 라이브러리 버전, @types버전, 타입스크립트 버전은 의존성과 관련된 세가지 버전입니다. 

- 라이브러리를 업데이트 하는경우, 해당 @types 역시 업데이트 해야합니다.

- 타입 선언을 라이브러리에 포함하는 것과 DefinitelyTyped에 공개하는 것 사이의 장단점을 이해해야합니다.

  타입스크립트로 작성된 라이브러리라면 타입 선언을 자체적으로 포함하고, 자바스크립트로 작성된 라이브러리라면 타입선언을 DefinitelyTyped에 공개하는 것이 좋습니다.