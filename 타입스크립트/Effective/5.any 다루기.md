# 이팩티브 타입스크립트

Effective TypeScript를 읽으며 배운점과 느낀점을 정리합니다.

---



전통적으로 프로그래밍 언어들의 타입 시스템은 완전히 정적이거나 완전히 동적입니다.

하지만 타입스크립트의 타입 시스템은 선택적입니다.

마이그래이션을 할때 (자바스크립트 코드를 타입스크립트로 전환) 일부분에 타입 체크를 비활성화 시켜야할 경우가 있습니다.

이때 `any` 는 매우 중요한 역할을 합니다.

또한 `any` 를 현명하게 사용하는 방법을 익혀야만 효과적인 타입스크립트 코드를 작성할 수 있습니다.

`any` 가 매우 강력한 힘을 가지므로 남용하게 될 소지가 높기 때문입니다.



## Item 38.

### any 타입은 가능한 한 좁은 범위에서만 사용하기

먼저, 함수와 관련된 any의 사용법을 살펴보겠습니다.

```typescript
function processBar(b :Bar) {/*...*/}

function f() {
    const x = expressionReturningFoo();
    processBar(x); // Error : 'Foo' 형식의 인수는 'Bar' 형식의 매개변수에 할당될수 없습니다.
}
```

문맥상으로 x라는 변수가 동시에 Foo 타입과 Bar 타입에 할당 가능하다면, 오류를 제거하는 방법은 두 가지 입니다.

```typescript
function f1() {
    const x: any = expressionReturningFoo(); // 정상이지만 이렇게 하면 안됩니다!
    processBar(x);
}
```

```typescript
function f2() {
    const x = expressionReturningFoo();
    processBar(x as any); // 이게 낫습니다.
}
```

위의 해결책중 f2의 함수 사용을 권장합니다.

**이유는 `any` 타입이 `processBar` 함수의 매개변수에서만 사용 사용된 표현식이므로 다른 코드에는 영향을 미치지 않기때문입니다.**

다음 코드를 보면 이해가 빠릅니다.

```typescript
function f() {
    const x: any = expressionReturningFoo();
    processBar(x);
    return x;
}

function g() {
    const foo = f(); // 타입이 any
    foo.fooMethod(); // 이 함수 호출은 체크 되지 않습니다.
}
```

위의 코드에서 `any` 를 반환하게 되면 그 **영향력은 프로젝트 전반에 전염병**처럼 퍼지게 됩니다.

반면 `any` 의 사용 범위를 좁게 제한하는 f2 함수를 사용한다면 any 타입이 함수 바깥으로 영향을 미치지 않습니다.

비슷한 관점에서, 타입스크립트가 함수의 반환 타입을 추론할 수 있는 경우에도 **함수의 반환 타입을 명시**하는것이 좋습니다.

함수의 반환 타입을 명시하면 `any` 타입이 함수 바깥으로 영향을 미치는 것을 방지 할 수 있습니다.

다음과 같이 아까의 오류를 해결할수 있습니다.

```typescript
function f() {
    const x = expressionReturningFoo();
    // @ts-ignore
    processBar(x);
    return x;
}
```

@ts-ignore를 사용한 다음 줄의 오류가 무시됩니다.

**그러나 근본적인 원인을 해결한 것이 아니기 때문에 다른 곳에서 더 큰 문제가 발생할 수도 있습니다.**

타입 체커가 알려 주는 오류는 문제가 될 가능성이 높은 부분이므로 근본적인 원인을 찾아 적극적으로 대처하는 것이 바람직합니다.



이번에는 객체와 관련된 `any`의 사용법을 살펴보겠습니다.

어떤 큰 객체 안의 한개 속성이 타입 오류를 가지는 상황을 예로 들어보겠습니다.

```typescript
const config: Config = {
    a: 1,
    b: 2,
    c: {
      key: value
      // ~~~ 'foo' 속성이 'Foo' 타입에 필요하지만 'Bar' 타입에는 없습니다.	
    }
};
```

단순히 생각하면 config 객체 전체를 `as any`로 선언해서 오류를 제거할 수 있습니다.

```typescript
const config = {
    a: 1,
    b: 2,
    c: {
      key: value
    }
} as any; // 이렇게 하지맙시다!
```

객체 전체를 `any`로 단언하면 다른 속성들 (a와 b) 역시 타입 체크가 되지 않는 부작용이 생깁니다.

그러므로 다음 코드처럼 최소한의 범위에만 `any` 를 사용하는 것이 좋습니다.

```typescript
const config = {
    a: 1,
    b: 2, // 이 속성은 여전히 체크됩니다.
    c: {
      key: value as any 
    }
};
```



### 요약

- 의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 합니다.
- 함수의 반환 타입이 any인 경우 타입 안정성이 나빠집니다. 따라서 any 타입을 반환하면 절대 안 됩니다.
- 강제로 타입 오류를 제거하려면 any 대신 @ts-ignore 사용하는 것이 좋습니다.