# 이팩티브 타입스크립트

Effective TypeScript를 읽으며 배운점과 느낀점을 정리합니다.

---



전통적으로 프로그래밍 언어들의 타입 시스템은 완전히 정적이거나 완전히 동적입니다.

하지만 타입스크립트의 타입 시스템은 선택적입니다.

마이그래이션을 할때 (자바스크립트 코드를 타입스크립트로 전환) 일부분에 타입 체크를 비활성화 시켜야할 경우가 있습니다.

이때 `any` 는 매우 중요한 역할을 합니다.

또한 `any` 를 현명하게 사용하는 방법을 익혀야만 효과적인 타입스크립트 코드를 작성할 수 있습니다.

`any` 가 매우 강력한 힘을 가지므로 남용하게 될 소지가 높기 때문입니다.



## Item 38.

### any 타입은 가능한 한 좁은 범위에서만 사용하기

먼저, 함수와 관련된 any의 사용법을 살펴보겠습니다.

```typescript
function processBar(b :Bar) {/*...*/}

function f() {
    const x = expressionReturningFoo();
    processBar(x); // Error : 'Foo' 형식의 인수는 'Bar' 형식의 매개변수에 할당될수 없습니다.
}
```

문맥상으로 x라는 변수가 동시에 Foo 타입과 Bar 타입에 할당 가능하다면, 오류를 제거하는 방법은 두 가지 입니다.

```typescript
function f1() {
    const x: any = expressionReturningFoo(); // 정상이지만 이렇게 하면 안됩니다!
    processBar(x);
}
```

```typescript
function f2() {
    const x = expressionReturningFoo();
    processBar(x as any); // 이게 낫습니다.
}
```

위의 해결책중 f2의 함수 사용을 권장합니다.

**이유는 `any` 타입이 `processBar` 함수의 매개변수에서만 사용 사용된 표현식이므로 다른 코드에는 영향을 미치지 않기때문입니다.**

다음 코드를 보면 이해가 빠릅니다.

```typescript
function f() {
    const x: any = expressionReturningFoo();
    processBar(x);
    return x;
}

function g() {
    const foo = f(); // 타입이 any
    foo.fooMethod(); // 이 함수 호출은 체크 되지 않습니다.
}
```

위의 코드에서 `any` 를 반환하게 되면 그 **영향력은 프로젝트 전반에 전염병**처럼 퍼지게 됩니다.

반면 `any` 의 사용 범위를 좁게 제한하는 f2 함수를 사용한다면 any 타입이 함수 바깥으로 영향을 미치지 않습니다.

비슷한 관점에서, 타입스크립트가 함수의 반환 타입을 추론할 수 있는 경우에도 **함수의 반환 타입을 명시**하는것이 좋습니다.

함수의 반환 타입을 명시하면 `any` 타입이 함수 바깥으로 영향을 미치는 것을 방지 할 수 있습니다.

다음과 같이 아까의 오류를 해결할수 있습니다.

```typescript
function f() {
    const x = expressionReturningFoo();
    // @ts-ignore
    processBar(x);
    return x;
}
```

@ts-ignore를 사용한 다음 줄의 오류가 무시됩니다.

**그러나 근본적인 원인을 해결한 것이 아니기 때문에 다른 곳에서 더 큰 문제가 발생할 수도 있습니다.**

타입 체커가 알려 주는 오류는 문제가 될 가능성이 높은 부분이므로 근본적인 원인을 찾아 적극적으로 대처하는 것이 바람직합니다.



이번에는 객체와 관련된 `any`의 사용법을 살펴보겠습니다.

어떤 큰 객체 안의 한개 속성이 타입 오류를 가지는 상황을 예로 들어보겠습니다.

```typescript
const config: Config = {
    a: 1,
    b: 2,
    c: {
      key: value
      // ~~~ 'foo' 속성이 'Foo' 타입에 필요하지만 'Bar' 타입에는 없습니다.	
    }
};
```

단순히 생각하면 config 객체 전체를 `as any`로 선언해서 오류를 제거할 수 있습니다.

```typescript
const config = {
    a: 1,
    b: 2,
    c: {
      key: value
    }
} as any; // 이렇게 하지맙시다!
```

객체 전체를 `any`로 단언하면 다른 속성들 (a와 b) 역시 타입 체크가 되지 않는 부작용이 생깁니다.

그러므로 다음 코드처럼 최소한의 범위에만 `any` 를 사용하는 것이 좋습니다.

```typescript
const config = {
    a: 1,
    b: 2, // 이 속성은 여전히 체크됩니다.
    c: {
      key: value as any 
    }
};
```



### 요약

- 의도치 않은 타입 안전성의 손실을 피하기 위해서 any의 사용 범위를 최소한으로 좁혀야 합니다.
- 함수의 반환 타입이 any인 경우 타입 안정성이 나빠집니다. 따라서 any 타입을 반환하면 절대 안 됩니다.
- 강제로 타입 오류를 제거하려면 any 대신 @ts-ignore 사용하는 것이 좋습니다.



## Item 39.

### any를 구체적으로 변형해서 사용하기

`any` 는 자바스크립트에서 표현할 수 있는 모든 값을 아우르는 매우 큰 범위의 타입입니다.

`any` 타입에는 모든 숫자, 문자열, 배열, 객체, 정규식, 함수, 클래스, DOM은 물론 null, undefined까지도 포함됩니다.

반대로 말하면, 일반적인 상황에서는 `any`보다더 구체적으로 표현할 수 있는 타입이 존재 할 가능성이 높기 때문에 더 구체적인

타입을 찾아 타입 안전성을 높이도록 해야합니다.

예를들어, `any` 타입의 값을 그대로 정규식이나 함수에 넣는 것은 권장하지 않습니다.

```typescript
function getLengthBad(array: any) { // 이렇게 하지 맙시다.
    return array.length;
}

function getLength(array: any[]) { // 이게 낫습니다.
    return array.length;
}
```

앞의 예제에서 `any` 를 사용하는 getLengthBad 보다는 `any[]` 를 사용하는 getLength가 더 좋은 함수입니다.

그 이유는 다음과 같습니다.

- 함수 내의 array.length 타입이 체크됩니다.
- 함수의 반환 타입이 any 대신 number로 추론됩니다.
- 함수 호출될 때 매개변수가 배열인지 체크됩니다.

배열이 아닌 값을 넣어서 실행해 보면, getLength는 제대로 오류를 표시하지만 getLengthBad는 오류를 잡아내지 못하는걸 볼 수 있습니다.

```typescript
getLengthBad(/123/); // 오류없음, undefined 반환
getLength(/123/); // 'any[]' 형식의 매개변수에 할당될 수 없습니다.
```

함수의 매개변수를 구체화할 때, 배열의 배열 형태하면 `any[][]` 처럼 선언하면 됩니다.

그리고 함수의 매개변수가 객체이긴 하지만 값을 알 수 없다면 `{[key: string]: any} ` 처럼 선언하면 됩니다.

```typescript
function hasTwelveLetterKey(o: {[key:string]: any}) {
    for (const key in o) {
        if (key.length === 12) {
            return true;
        }
    }
    return false;
}
```

위의 예제처럼 함수의 매개변수가 객체지만 값을 알 수 없다면 `{[key:string]: any}` 대신 

모든 비기본형(non-primitive) 타입을 포함하는 `object` 타입을 사용할수 있습니다.

하지만 `object` 타입은 객체의 키를 열거할 수는 있지만 속성에 접근할수 없다는 점에서 다릅니다.

```typescript
function hasTwelveLetterKey(o: object) {
    for (const key in o) {
        if (key.length === 12) {
            console.log(key, o[key]) // Error: '{}' 형식에 인덱스 시그니처가 없으므로 요소에 암시적으로 'any' 형식이 있습니다.
            return true;
        }
    }
    return false;
}
```



객체지만 속성에 접근할 수 없어야 한다면 `unknown` 타입이 필요한 상황일 수 있습니다.

함수의 타입에도 단순히 `any` 를 사용해서는 안됩니다.

최소한으로나마 구체화할 수 있는 세가지 방법이 있습니다.

```typescript
type Fn0 = () => any; // 매개변수 없이 호출 가능한 모든 함수
type Fn1 = (arg: any) => any; // 매개변수 1개
type Fn2 = (...args: any[]) => any; // 모든 개수의 매개변수

// ... 문법은 ES6에 도입된 나머지 매개변수와 전개 연산자입니다.
```

앞의 예제에 등장한 세 가지 함수 타입모두 `any` 보다는 구체적입니다.

마지막 줄을 잘 보면 `...args` 의 타입을 `any[]` 로 선언했습니다.

`any` 로만 선언해도 동작하지만 `any[]` 로 선언하면 배열 형태라는 것을 알 수 있어 더 구체적입니다.

```typescript
const numArgsBad = (...args: any) => args.length; // 타입이 any

const numArgsGood = (...args: any[]) => args.length; // 타입이 number
```



### 요약

- any를 사용할 때는 정말로 모든 값이 허용되어야만 하는지 면밀히 검토해야합니다.
- any보다 더 정확하게 모델링할 수 있도록 `any[]` 또는 `{[id: string]: any}` 또는 `() => any` 처럼 구체적인 형태를 사용해야합니다.





