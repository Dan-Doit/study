# 이팩티브 타입스크립트

Effective TypeScript를 읽으며 배운점과 느낀점을 정리합니다.

---



산업계에서 사용되는 프로그래밍 언어들에서는 '정적 타입' 과 '명시적 타입'이 전통적으로 같은 의미로 쓰였습니다.

그래서 C, C++, 자바에서는 타입을 직접 명시합니다.

그러나 학술계에서는 이 두가지 타입을 절대 혼동해서 쓰지 않습니다. 

학술계로 분류되는 ML과 하스켈 같은 언어는 오래전부터 정교한 타입추론 기능이 존재해왔습니다.

그래서 산업계 언어인 C++ 는 auto를 자바는 var 를 추가 하여 타입 추론 기능을 수행 했습니다.

타입추론은 많은 양의 코드를 줄여주며 코드의 전체적인 안정성도 향상이 됩니다.



타입스크립트 또한 타입 추론을 적극적으로 수행합니다.

타입추론은 수동으로 명시해야 하는 타입 구문의 수를 엄청나게 줄여주기 때문에, 코드의 전체적인 안정성이 향상됩니다.

숙련된 타입스크립트 개발자와 초보자는 타입수에서 엄청난 차이가 발생합니다.

우리는 이번장에서 타입스크립트가 타입을 어떻게 추론하는지, 

언제 타입 선언을 작성해야하는지, 

타입 추론이 가능하더라도 명시적으로 타입 선언을 작성하는것이 필요한 상황은 언제인지 잘 이해 할 수 있을것입니다.





## Item 19.

### *추론 가능한 타입을 사용해 장황한 코드 방지하기*

타입스크립트를 처음 접한 개발자가 자바스크립트 코드를 포팅할 때 가장 먼저 하는 일은 타입 구문을 넣는 것입니다.

타입스크립트는 결국 타입언어이기에 변수를 선언할 때마다 타입을 명시해야 한다고 생각하기 때문입니다.

그러나 타입스크립트의 많은 타입 구문은 사실 불필요합니다.



- ### 다음과 같은 코드는 비생산적이고 형편없는 코드라고 여겨집니다.

  ```typescript
  let x: number = 21;
  ```

  다음처럼만 해도 충분합니다.

  ```typescript
  // 이미 타입을 추론합니다.
  let x = 21;
  ```

  

- ### 타입스크립트는 더 복잡한 객체도 추론이 가능합니다.

  ```typescript
  const person: {
    name: string;
    age: number;
    phoneNumber: string;
  } = {
    name: 'dan',
    age: 2,
    phoneNumber: 'number',
  };
  ```

  타입을 생략하고 다음처럼만 해도 충분합니다.

  ```typescript
  const person = {
    name: 'dan',
    age: 2,
    phoneNumber: 'number',
  };
  ```

  

- ### 타입스크립트는 함수에 대해서도 정확한 추론이 가능합니다.

  ```
  function square(nums: number[]) {
    return nums.map(x => x * x);
  }
  
  const squares = square([1, 2, 3, 4]);
  ```

  ![image-20220216091521692](file:///Users/dan/Documents/Study/%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%B8%E1%84%90%E1%85%B3/Effective/3.%E1%84%90%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B8%E1%84%8E%E1%85%AE%E1%84%85%E1%85%A9%E1%86%AB.assets/image-20220216091521692.png?lastModify=1644970517) 

  추론이 잘 되었습니다.



- ### 비구조화 할당으로 타입을 정리하는것이 좋습니다.

  타입스크립트의 추론은 꽤 유용합니다.

  다음 코드를 보면 문제가 있습니다.

  ```typescript
  interface Product {
    id: number;
    name: string;
    price: number;
  }
  
  function logProduct(product: Product) {
    const id: number = product.id;
    const name: string = product.name;
    const price: number = product.price;
    console.debug(id, name, price);
  }
  ```

  만약 id 값에서 number가 아닌 uuid가 들어온다고 가정을 하면 우리는 string으로 변경을 해주어야합니다.

  ```typescript
  interface Product {
    id: string;
    name: string;
    price: number;
  }
  ```

  그러면 바로 함수에서 에러가 발생합니다.

  ![image-20220216092039591](3.타입추론.assets/image-20220216092039591.png) 

   

  이런식으로 변수의 타입을 일일이 지정하는 방식보다는 비구조화 할당문으로 구현하는게 좋습니다.

  비구조화 할당문은 모든 지역 변수의 타입이 추론되도록합니다.

  ```typescript
  function logProduct(product: Product) {
    const { id, name, price } = product;
    console.debug(id, name, price);
  }
  ```

  

- ### 정보가 부족해서 타입스크립트가 스스로 타입판단을 하기 어렵다면 명시적 타입 구문이 필요합니다.

  어떤 언어들은 매개변수의 최정 사용처까지 참고하여 타입을 추론하지만

  타입스크립트는 최종 사용처까지 고려하지 않습니다.

  타입 스크립트에서 변수의 타입은 일반적으로 처음 등장할 때 결정됩니다.

  

  이상적인 타입스크립트 코드는 함수/메서드 시그니처 타입 구문을 포함하지만,

  함수 내에서 생성된 지역 변수에는 타입 구문을 넣지않습니다.

  **타입구문을 생략하여 방해되는 것들을 최소화하고 코드를 읽는 사람이 구현 로직에 집중**할 수 있게 하는것이 좋습니다.

  다음은 express HTTP 서버 라이브러리를 사용하는 req, res 타입 코드입니다.

  ```typescript
  // 이렇게 하면 안됨!
  app.get('/health', (request: express.Request, response: express.Response) => {
  	response.send('OK');
  });
  ```

  ```typescript
  // 이렇게 하자!
  app.get('/health', (request, response) => {
  	response.send('OK');
  });
  ```

  위와같은 라이브러리의 시그니처는 이미 타입 추론이 되기 때문에 굳이 타입을 명시하여 코드의 양을 늘리지 않는것이 좋습니다.

  

- ### 함수의 반환에도 타입을 명시하여 오류를 방지할수 있습니다.

  아래 fetch 함수를 보자

  ```typescript
  function getData(arg: string) {
    return fetch(`localhost:3001/?q=${arg}`).then(res => res.json());
  }
  ```

  이 함수에서 우리는 조회된 데이터를 캐싱하여 다시 요청하지 않도록 하자.

  ```typescript
  const cache: { [data: string]: number } = {};
  
  function getData(arg: string) {
    if (arg in cache) {
      return cache[arg];
    }
    return fetch(`localhost:3001/?q=${arg}`)
      .then(res => res.json())
    	// 캐시에 데이터 저장후 리턴
      .then(data => {
        cache[arg] = data;
        return data;
      });
  }
  ```

  하지만 이 함수는 오류가 있습니다.
  

  getData는 항상 Promise를 반환 하므로 if 구문에는 `cache[arg]`가 아닌 

  `Promise.resolve(cache[arg])` 가 반환되도록 해야합니다.


  이때 의도된 반환 타입에 `Promise<number>` 를 명시한다면, 정확한 위치에 오류가 표시됩니다.

  ![image-20220216094451783](3.타입추론.assets/image-20220216094451783.png)



이외적으로 반환타입을 명시하면 좋은점이 두가지 있습니다.

- 반환타입을 명시하면 함수에 대해 더욱 명확하게 알 수가 있다.
- 명명된 타입을 사용하기 위해서입니다.

만약 eslint를 사용한다면 규칙중에 no-inferrable-types을 사용하여 모든 타입 구문이 필요한지 확인할 수 있습니다.



### 요약

>- 타입스크립트가 타입을 추론할수 있다면 타입구문을 작성하지 않는것이 좋다.
>- 이상적인 경우 함수의 시그니처에는 타입 구문이 있지만, 함수 내의 지역변수에는 타입 구문이 없다.
>- 추론될 수 있는 경우라도 객체 리터럴과 함수 반환에는 타입 명시를 고려해야한다.
>  이는 내부 구현의 오류가 사용자 코드 위치에 나타나는것을 방지 해준다.





## Item 20.

### 다른 타입에는 다른 변수 사용하기

자바스크립트에서는 한 변수를 다른 목적을 가지는 다른타입으로 재 사용해도됩니다.

```javascript
// javascript
let id = '2a13-gg21';
id = 12345;
```

하지만 타입스크립트에서는 위와같은 상황이 불가능합니다.

```typescript
// typescript
let id = '2a13-gg21';
id = 12345; // Error : string 형식에 number 형식은 할당될 수 없습니다.
```

이유는 타입스크립트에서 선언당시에 추론을 하였기 떄문입니다.

두가지 타입을 사용하려면 아래와 같이 union 타입을 사용하여야 합니다.

```typescript
// typescript
let id: string|number = '2a13-gg21';
id = 12345; // 정상
```

하지만 위와같은 코드는 **다른 문제를 야기**합니다.



언제 어느 순간 `string` 타입인지 `number` 타입인지를 분간해서 코드를 작성해야합니다.

*가령 function 안에 argument로 사용한다던지*

그래서 별도의 변수로 사용하는것이 더 좋습니다.

```typescript
// typescript
const id = '2a13-gg21';
getDetailById(id);

const serial = 12345;
getDetailBySerial(serial);
```

다음의 이유로 분리 하여야합니다.

- 서로 관련이 없는 두개의 값을 분리합니다.
- 변수명을 더 구체적으로 지을수 있습니다.
- 타입 추론을 향상시키며, 타입 구문이 불필요해집니다.
- 타입이 좀 더 간결해집니다.
- `let`대신 `const`로 변수를 선언하게 됩니다.
- `const`로 변수를 선언하면 코드가 간결해지고, 타입 체커가 타입을 추론하기에 좋습니다.



### 요약

>- 변수의 값은 바뀔 수 있지만 타입은 일반적으로 바뀌지 않습니다.
>- 혼란을 막기 위해 타입이 다른 값을 다룰 때에는 변수를 재사용하지 않도록 합니다.