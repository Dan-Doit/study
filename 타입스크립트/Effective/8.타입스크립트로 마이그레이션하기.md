# 이팩티브 타입스크립트

Effective TypeScript를 읽으며 배운점과 느낀점을 정리합니다.

---

타입스크립트는 자바스크립트보다 개선된 언어입니다. 그러므로 프로젝트를 새로 시작한다면 처음부터 타입스크립트를 사용하면 됩니다.

그런데 규모가 크고 오래된 자바스크립트 프로젝트가 이미 존재한다면, 그 프로젝트를 타입스크립트로 전환하기에 시간이 많이듭니다.

그렇다고 그대로 자바스크립트로 유지보수하는 것도 매우 고통스러울 겁니다.



이번장에서는 덩치 크고 낡은 자바스크립트 프로젝트라고 할지라도, 꾸준하게 타입스크립트로 마이그레이션 할 수 있게 해주는 몇가지 방법을 소개합니다.



한꺼번에 많은 코드를 타입스크립트로 전환할 수 없기 때문에, 대규모 프로젝트를 마이그레이션할 때는 점진적으로 전환해야 합니다.

마이그레이션 작업은 오랜 시간이 필요하기 때문에, 진행 상황을 모니터링하고 추적해서 중복된 작업을 방지할 수 있어야 합니다.

마이그레이션이 얼마나 진행되었고 현재 상황이 어떤지 수치화하여 눈으로 볼 수 있게하면 팀원들에게 동기부여도 될 겁니다.

**주의점**

대부분의 예제가 순수 자바스크립트여서 타입스크립트 컴파일러에서는 오류가 발생할수 있습니다.

타입 체크 설정을 해제(`noImplicitAny:off`)하여 타입체크가 동작하지 않도록 해야합니다.



## Item 58.

### 모던 자바스크립트로 작성하기

타입스크립트는 타입 체크 기능 외에, 타입스크립트 코드를 특정 버전의 자바스크립트로 컴파일 하는 기능도 가지고 있습니다.

심지어 1999년에 나온 ES3버전의 자바스크립트 '트랜스파일러'로 사용할 수도 있습니다.

타입스크립트는 자바스크립트의 상위 집합이기 때문에, 최신 버전의 자바스크립트 코드를 옛날 버전의 자바스크립트 코드로 변환할 수 있습니다.

따라서 마이그레이션을 어디서부터 시작해야 할지 몰라 막막하다면 옛날 버전의 자바스크립트 코드를 최신 버전의 자바스크립트로 바꾸는 작업부터 시작해 보는것이 좋습니다.



### ECMAScript 모듈 사용하기

ES2015 이전에는 코드를 개별 모듈로 분할하는 표준 방법이 없었지만, 지금은 개별 모듈로 분할하는 방법이 많아졌습니다.

여러개의 `<script>` 태그를 사용하기, 직접 갖다 붙이기, `Makefile` 기법, `NodeJS` 스타일의 require 구문, AMD 스타일의 define 콜백까지 매우 다양합니다.

ES2015부터는 임포트`import` 익스포트 `export` 를 사용하는 ECMAScript 모듈이 표준이 되었습니다.

만약 마이그레이션 대상인 자바스크립트 코드가 단일 파일이거나 비표준 모듈 시스템을 사용중이라면 ES모듈로 전환하는 것이 좋습니다.

그리고 ES모듈 시스템을 사용하기 위해서 프로젝트 종류에 따라 웹팩(webpack)이나 ts-node 같은 도구가 필요한 경우도 있습니다.

ES 모듈 시스템은 타입스크립트에서도 잘 동작하며, 모듈 단위로 전활할 수 있게 해주기 때문에 점진적 마이그레이션이 원활해집니다.



### 프로토타입 대신 클래스 사용하기

과거에는 자바스크립트에서 프로토타입 기반의 객체 모델을 사용했습니다.

그러나 많은 개발자가 사용하기 애매한 프로토타입 모델보다는 견고하게 설계된 클래스 기반 모델을 선호했기 때문에, 

결국 ES2015에 `class` 키워드를 사용하는 클래스 기반 모델이 도입되었습니다.

마이그레이션하려는 코드에서 단순한 객체를 다룰 때 프로토타입을 사용하고 있었다면 클래스로 바꾸는 것이 좋습니다.

다음은 단순 객체를 프로토타입으로 구현한 예제입니다.

```typescript
function Person(first, last) {
  this.first = first;
  this.last = last;
}

Person.prototype.getName = function() {
  return this.first + ' ' + this.last;
}

const marie = new Person('Marie', 'Curie');
const personName = marie.getName();
```



프로토타입 기반 객체를 클래스 기반 객체로 바꾸면 다음과 같습니다.

```typescript
class Person {
  first: string;
  last: string;
  
  constructor(first: string, last: string){
    this.first = first;
    this.last = last;
  }
  
  getName() {
    return this.first + ' ' + this.last;
  }
}

const marie = new Person('Marie', 'Curie');
const personName = marie.getName();
```



프로토타입으로 구현한 Person 객체보다 클래스로 구현한 Person 객체가 문법이 간결하고 직관적입니다.

클래스 문법에 익숙하지 않더라도 타입스크립트언어 서비스를 활용하면 클래스를 간단히 작성할 수 있습니다.

편집기에서 프로토타입 객체에 마우스를 올려, 타입스크립트 언어 서비스인 '함수를 ES2015클래스로 변환'을 선택하면 간단히 클래스 객체로 변환할 수 있습니다.



### Var대신 let/const 사용하기

자바스크립트 var 키워드의 스코프 규칙에는 문제가 있다는 것은 널리 알려진 사실입니다.

var대신 let과 const를 사용하면 스코프 문제를 피할수 있습니다.

let과 const는 제대로 된 블록스코프 규칙을 가지며, 개발자들이 일반적으로 기대하는 방식으로 동작합니다.

만약 var 키워드를 let/const 로 변경하면, 일부 코드에서 타입스크립트가 오류를 표시할수도 있습니다.

오류가 발생한 부분은 잠재적으로 스코프 문제가 존재하는 코드이기 때문에 수정해야합니다.



### for(;;) 대신 for-of 또는 배열 메서드 사용하기

과거에는 자바스크립트에서 배열을 순회할 때 C스타일의 `for` 루프를 사용했습니다.

```javascript
for (var i = 0; i < array.length; i++) {
	const el = array[i];
}
```

모던 자바스크립트에서는 `for-of` 루프가 존재합니다.

```javascript
for (const el of array) {
	// ...
}
```

`for-of` 루프는 코드가 짧고 인덱스 변수를 사용하지도 않기 때문에 실수를 줄일수 있습니다.

인덱스 변수가 필요한 경우엔 forEach 메서드를 사용하면 됩니다.

```javascript
array.forEach((el, i) => {
	//...
});
```

`for-in` 문법도 존재하지만 몇 가지 문제점이 있기때문에 사용하지 않는 것이 좋습니다.



### 함수 표현식보다 화살표 함수 사용하기

`this` 키워드는 일반적인 변수들과는 다른 스코프 규칙을 가지기 때문에, 자바스크립트에서 가장 여려운 개념중 하나입니다.

일반적으로는 `this`가 클래스 인스턴스를 참조하는 것을 기대하지만 다음 예제처럼 예상치 못한 결과가 나오는 경우도 있습니다.

```typescript
class Foo {
  method() {
    console.log(this);
    [1, 2].forEach(funtion(i) {
    	console.log(this)               
    })
  }
}
const f = new Foo();
f.method();
// strict 모드에서는 Foo, undefind, undefind 를 출력합니다.
// non-strict 모드에서는 Foo, window, window (!)를 출력합니다.
```



대신 화살표 함수를 사용하면 상위 스코프의 `this`를 유지 할 수 있습니다.

```typescript
class Foo {
    method() {
    console.log(this);
    [1, 2].forEach(i => {
    	console.log(this)               
    })
  }
}
const f = new Foo();
f.method();
// 항상 Foo, Foo, Foo를 출력합니다.
```

인라인에서는 일반함수보다 화살표 함수가 더 직관적이며 코드도 간결해지기 때문에 가급적 화살표 함수를 사용하는 것이 좋습니다.

그리고 컴파일러 옵션에 noImplicitThis(또는 strict)를 설정하면, 타입스크립트가 this 바인딩오류를 표시해 주므로 설정하는 것이 좋습니다.



### 단축 객체 표현구조 분해 할당 사용하기

Pt 객체를 생성하는 다음 코드를 보겠습니다.

```typescript
const x = 1, y = 2, z = 3;
const pt = {
  x: x,
  y: y,
  z: z
};
```

변수와 객체 속성의 이름이 같다면, 간단하게 다음 코드처럼 작성할 수 있습니다.

```typescript
const x = 1, y = 2, z = 3;
const pt = { x, y, z };
```

앞의 두 예제 중 후자의 코드가 더 간결하고 중복된 이름을 생략하기 때문에 가독성이 좋고 실수가 적습니다.



화살표 함수 내에서 객체를 반환할 때는 소괄호로 감싸야합니다.

현부에는 블록이나 단일 표현식이 필요하기 때문에 소괄호로 감싸서 표현식으로 만들어 준 것 입니다.

```typescript
() => ({a: 1, b: 2, c: 3})
```



단축 객체의 표현의 반대는 객체 구조 분해입니다.

```typescript
const props = obj.props;
const a = props.a;
const b = props.b;
```

다음처럼 사용이 가능합니다.

```typescript
const { props } = obj;
const { a, b } = props;
```

극단적으로 다음과 같이 줄일수 있습니다.

```typescript
const { props : { a, b } } = obj;
```

default 값을 기본값으로 지정할수도 있습니다.

```typescript
const { a = 'defualt' } = obj.props
```

배열 구조에서도 사용을 할수 있습니다. 

```typescript
const point = [ 1, 2, 3 ];

const [x, y, z] = point;
const [, a, b] = point; // 첫번째 요소 무시
```

단축 객체와 마찬가지로, 객체 구조 분해를 사용하면 문법이 간결해지고 변수를 사용할 때 실수를 줄일 수 있기 떄문에 적극적으로 사용하는 것이 좋습니다.



### 함수 매개변수 기본값 사용하기

자바스크립트에서 함수의 모든 매개변수는 선택적(생략 가능)이며, 매개변수를 지정하지 않으면 `undefined`로 간주됩니다.

그렇기 때문에 이미 기본값을 사용하면 코드가 간결해질 뿐만 아니라 선택적 매개변수라는것을 명확히 나타내는 효과도 줄수 있습니다.

```typescript
const test (a, b = 10) => { // 기본값 사용하기
	console.log(a, b)
}
```





### 저수준 프로미스나 콜백 대신 async/await 사용하기

일반적으로 사용하는 `fetch` 코드보다 `async/await` 을 사용하는것이 코드상에 더 간결하고 직관적입니다.



### 연관 배열에 객체 대신 Map과 Set사용하기



### 타입스크립트에 use strict 넣지 않기

ES5에서는 버그가 될수 있는 코드 패턴에 오류를 표시해주는 **엄격모드(strict mode)**가 도입되었습니다.

그러나 타입스크립트에서 수행되는 안정성 검사가 엄격모드보다 훨씬 더 엄격한 체크를 하기때문에, 타입스크립트 코드에서 `use strict` 는 무의미합니다.

실제로는 타입스크립트 컴파일러가 생성하는 자바스크립트 코드에서 `use strict` 가 추가됩니다.

alwaysStrict 또는 strict 컴파일러 옵션을 설정하면, 타입스크립트는 엄격 모드로 코드를 파싱하고 생성되는 자바스크립트에 `use strict` 를 추가합니다.

즉, 타입스크립트 코드에 `use strict`를 쓰지 않고, 대신 alwaysStrict 설정을 사용해야합니다.

